/~ -----------------------------------------------------------------------------
   Copyright 2014 Murray Lang

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
   -----------------------------------------------------------------------------   
   
   The format of this file is as specified for JS/CC: 
		http://jscc.phorward-software.com/
   Kudos to Jan Max Meyer for providing such a useful tool free of charge.
   
   This file describes a parser for a variant of the Logo programming language.
   It's based on Cricket Logo, but I've endeavoured to provide a somewhat more
   comprehensive set of Logo language features. I've used Berkley Logo as my
   reference and have not added any key words that are not in the Berkley 
   standard.
~/
	
	
[*

//--------------------------------------------------------------------------
// My stuff
var enumArgType = 
{ 
	UNKNOWN :   -1, 
	PROC_ADDR :  0, 
	VAR :        1,
    COUNTER:     2,
	TAG_DECL:    3,
	TAG_REF:     4,
	BYTE :       5, 
	SHORT :      6 
};

function VmCode(length, code, arg, argType, comment)
{
	this.address      = -1;
	this.length       = length;
	this.code         = code;
	this.argument     = arg;
	this.argumentType = argType;
	this.comment      = comment;
	this.xref         = null;
	this.xrefResolved = false;
		// This member was added so that "byte n" commands that are variable 
		// indexes can have a convenient reference to the 
		//(set|get)(global|local|temp|param) command code.
	this.partnerCode  = null;
}

VmCode.prototype.asAssembly = 
	function ()
	{
		if (this.length == 0)
			return "";
			// 4 digit padding of address
		var	str = (10000 + this.address + ": ").substr(1);
		str += this.code;
		if (this.argument !== undefined && this.argument != null)
			str += " " + this.argument;

		if (this.comment !== undefined && this.comment != null)
			str += "\t\t;" + this.comment;
		return str;
	};

function Variable(name, index)
{
	this.name  = name;
	this.index = index;
}

function TagAddress(name, address)
{
	this.name  = name;
	this.index = address;
}

function ProcedureCall(name, args, returnsValue, returnValueRequired, parserSeesArgList)
{
	this.name = name;
	this.argList = args;
	this.returnsValue = returnsValue;
	this.returnValueRequired = returnValueRequired;
	this.parserSeesArgList = parserSeesArgList;
}

function ProcedureDefinition(name, parameters, statements)
{
	this.name       = name;
	this.parameters = parameters;
	this.statements = statements;
	this.address    = null;		// Calculated when the procedure is linked to the code
	this.variables  = new Array();
	this.returnsValue = false; // This will be determined later by looking for "output"
}

ProcedureDefinition.prototype.toString = 
	function ()
	{
		var str = "--------------------------------\n";
		str += "Name:            " + (this.name === undefined ? "undefined" : this.name == null ? "null" : this.name) + "\n";
		str += "Address:         " + (this.address === undefined ? "undefined" : this.address == null ? "null" : this.address) + "\n";
		str += "#Parameters:     " + (this.parameters === undefined ? "0" : this.parameters == null ? "0" : this.parameters.length) + "\n";
		str += "#Statements:     " + (this.statements === undefined ? "0" : this.statements == null ? "0" : this.statements.length) + "\n";
		str += "#Variables:      " + (this.variables === undefined ? "0" : this.variables == null ? "0" : this.variables.length) + "\n";
		str += "Returns a value: " + (this.returnsValue ? "true\n" : "false\n");
		str += "--------------------------------\n";
		
		return str;
	};

ProcedureDefinition.prototype.assignAddresses = 
	function (startAddress)
	{
		if (this.statements === undefined || this.statements == null)
			return startAddress;
			
		this.address    = startAddress;
		var nextAddress = startAddress;
		for (var i = 0; i < this.statements.length; i++)
		{
			this.statements[i].address = nextAddress;
			nextAddress += this.statements[i].length;
		}
		return nextAddress;
	};
	
ProcedureDefinition.prototype.resolveGotos =	
	function ()
	{
		if (this.statements === undefined || this.statements == null)
			return;
		for (var i = 0; i < this.statements.length; i++)
		{
				// Is it a goto
			if (this.statements[i].argumentType == enumArgType.TAG_REF)
			{
					// Yes. Start from the beginning and look for the tag (label)
				for (var j = 0; j < this.statements.length; j++)
				{
					if (this.statements[j].argumentType == enumArgType.TAG_DECL)
					{
						if (this.statements[j].argument == this.statements[i].xref)
						{
							this.statements[i].argument = this.statements[j].address;
							this.statements[i].xrefResolved = true;
							break;
						}
					}
				}
			}
		}
	};

ProcedureDefinition.prototype.findProcedureAddress =
	function (allProcedures, name)
	{
		//this.errorOutput("Resolving address for " + name);
		for (var i = 0; i < allProcedures.length; i++)
		{
			if (allProcedures[i].name == name)
			{
				if(allProcedures[i].address !== undefined)
				{
					//this.errorOutput("found " + name + " at " + procedureDefinitions[i].address);
					return allProcedures[i].address;
				}
			}
		}
		return -1;
	};	
	
ProcedureDefinition.prototype.resolveProcedureCrossReferences =	
	function (allDefinitions)
	{
		if (this.statements === undefined || this.statements == null)
			return;
		for (var i = 0; i < this.statements.length; i++)
		{
			if (this.statements[i].argumentType === undefined || this.statements[i].argumentType == null)
				continue;
			if (this.statements[i].argumentType !== enumArgType.PROC_ADDR)
				continue;
			if (this.statements[i].xref === undefined || this.statements[i].xref == null)
				continue;
			
			var address = this.findProcedureAddress(allDefinitions, this.statements[i].xref);
			if (address == -1)
			{
				this.errorOutput("Unable to resolve address for " + this.statements[i].xref);				
			}
			else
			{
				this.statements[i].argument = address;
				this.statements[i].xrefResolved = true;
			}
		}
	};	

ProcedureDefinition.prototype.addVariable =
	function (variables, name, id)
	{
		var newVar   = new Variable(name, variables.length);
		//newVar.name  = name;
			// if an id is provided then use it, otherwise use the index
			// into the array that holds the variable.
		if (id === undefined)
			newVar.index = variables.length;
		else
			newVar.index = id;
		variables.push(newVar);
		return newVar.index;
	};
	
ProcedureDefinition.prototype.findVariable =
	function (variables, name)
	{
		var i;
		for( var i = 0; i < variables.length; i++ )
			if( variables[i].name == name )
				return variables[i].index;
		return -1;
	};

ProcedureDefinition.prototype.resolveVariables = 
	function (globalVariables) //(codes, inProcedure, parameters)
	{
		if (this.statements === undefined || this.statements == null)
			return

			// If in global scope then use global variable table
		//var localVariables = global ? globalVariables : this.variables;
		//var localVariables = new Array();        // Variables local to a procedure
		var blockVariables = new Array();        // Stack of tables of variables
				// Counters (as used in for loops etc.) are a special case of
				// variable. Visible inside the loop, visible to the "for"
				// construct outside the loop, but not visible to code at the
				// same level as the for statement.
		//var counters = new Array();        // Stack of counter variables
				// All variables local to all blocks (eg loops) actually get stored
				// in a single array. This counter provides the index into this
				// array, while variables are actually managed here using a stack
				// of tables. (see description below)
		//var nextTempVariableIndex = 0;
		var counter = null;
		for (var i = 0; i < this.statements.length; i++)
		{
					// A "counter" argument type means that the code is a "byte" that 
					// needs to be resolved to a counter variable index. 
					// The counter is stored in the same array as temporary variables 
					// (but can only be resolved in the corresponding block and by the 
					// "for" construct).
					// These always occur just before a block.
			if (this.statements[i].argumentType == enumArgType.COUNTER)
			{
					// This will get put into the list of local variables for
					// the next block that comes along.
					
					// Create an anonymous local variable to store the temp variable
				var tempVarIndex = this.addVariable(this.variables, null);
				counter = new Variable(this.statements[i].xref, tempVarIndex);
				//counters.push(counter);
					// Borrow the msb of the variable index to use as a flag
					// indicating the first iteration of a loop. This tactic will
					// obviously fail if we have any more than 127 local variables.
				this.statements[i].argument = counter.index | 128;
				this.statements[i].xrefResolved = true;
				continue;
			}
			
				// If we're in a '[' block ']' then a variable might be in that
				// scope. Blocks/loops can be nested, with deeper blocks able to
				// access the variables of outer blocks but not vice versa. So
				// for each level, an array of variables is created and put on
				// a stack (another array). All temporary variables will
				// ultimately be assigned an index into a single array that
				// holds them all, but the stack of tables here is a temporary
				// device to limit the scope of lookups. All searches will start
				// at the top of the stack (the end of the array of tables) and
				// work backwards through the tables. As a block is exited, its
				// variable table is popped off the stack so that outer blocks
				// don't get access to it.
			if (this.statements[i].code == "block")
			{
						// A new variable table for this level
				var tempVariables = new Array();
						// If there's a counter variable then push it onto the table
						// to make it visible to the block.
				if (counter != null)
				{
						tempVariables.push(counter);
						counter = null;
				}
				blockVariables.push(tempVariables);
				continue;
			}
			if (this.statements[i].code == "eob")
			{
						// Take variables in this block out of scope
				blockVariables.pop();
				continue;
			}
			
			if (this.statements[i].argumentType === undefined || this.statements[i].argumentType == null)
				continue;
					
			if ( this.statements[i].argumentType != enumArgType.VAR)
					continue;
					
			if (this.statements[i].xref === undefined || this.statements[i].xref == null)
			{
					this.errorOutput("Cross reference expected but undefined.");
					continue;
			}
					// Need to look at the next code to see if it's a set or get.
					// Make sure there's actually a next code.
			if ((i + 1) >= this.statements.length)
			{
				this.errorOutput("Unexpected end of code.");
				return;
			}
			if (this.statements[i].partnerCode == null)
			{
				continue;
			}
			var isGet = this.statements[i].partnerCode.code == "<getvar>";
			
			var globalIndex = -1;         
			var localIndex = -1;
			var paramIndex = -1;
				// Start from the innermost level and work outwards
				// Firstly variables declared/first used in a block
			if (blockVariables.length > 0)
			{
					// We're in a block.
					// Search the stack of tables, starting with the innermost
					// table (this block's).
				for (var tableIndex = blockVariables.length -1; tableIndex >=0; tableIndex--)
				{
					var nextTable = blockVariables[tableIndex];
					localIndex = this.findVariable(nextTable, this.statements[i].xref);
					if (localIndex != -1)
						break;        // Found it
				}
			}
				// if not in a block then try variables local to the procedure
			if (localIndex == -1)
				localIndex = this.findVariable(this.variables, this.statements[i].xref);
				
			if (localIndex != -1)        // The variable is local to a procedure.
			{
					this.statements[i].argument = localIndex;
					this.statements[i].xrefResolved = true;
					this.statements[i].partnerCode.code = isGet ? "getlocal" : "setlocal";
					continue;
			}
				// Not local. Try the function parameters
			if (this.parameters !== null)
			{
					// Search parameters for the id and return the index if found
				for( var j = 0; j < this.parameters.length; j++ )
					if( this.parameters[j] == this.statements[i].xref )
						paramIndex = j;
			}
			if (paramIndex != -1)
			{
					// It's a function parameter
				if (!isGet)
				{
					this.errorOutput("Cannot assign a value to procedure parameter " + this.statements[i].xref);
				}
				this.statements[i].argument = paramIndex;
				this.statements[i].xrefResolved = true;
				this.statements[i].partnerCode.code = "getparam";        // Can't set a parameter (at this stage)
				continue;
			}
				// It's not a function parameter. Try the global variables.
				// If globalVariables == null, then this procedureDefinition is
				// the mainline and its local variables are in fact the globals
			if (globalVariables == null)
				globalIndex = this.findVariable(this.variables, this.statements[i].xref);
			else
				globalIndex = this.findVariable(globalVariables, this.statements[i].xref);
			
			if (globalIndex != -1)        // It's a global variable.
			{
					this.statements[i].argument = globalIndex;
					this.statements[i].xrefResolved = true;
					this.statements[i].partnerCode.code = isGet ? "getglobal" : "setglobal";
					continue;
			}
					// Not found anywhere. If we're just getting the variable then
					// this is an error.
			if (isGet)
			{
					this.errorOutput("The variable \"" + this.statements[i].xref + "\" is undefined.");
					continue;
			}
					// Reaching this point means that we're setting a variable that
					// doesn't exist. In LOGO that means it should be created. Decide
					// where it belongs based on the scope.
			if (blockVariables.length > 0)
			{
							// We're creating a variable within a block, so make it
							// that scope.
					var thisBlocksTable = blockVariables[blockVariables.length - 1];
						// add an anonymous local variable to store the temporary variable
					var tempVarIndex = this.addVariable(this.variables, null);
					this.statements[i].argument = this.addVariable(thisBlocksTable, this.statements[i].xref, tempVarIndex);
					this.statements[i].xrefResolved = true;
					this.statements[i].partnerCode.code = "setlocal"; //"settemp";
					continue;
			}
				// If globals aren't null then we're in a procedure
			if (globalVariables != null)
			{
				localIndex = this.addVariable(this.variables, this.statements[i].xref);
				this.statements[i].argument = localIndex;
				this.statements[i].xrefResolved = true;
				this.statements[i].partnerCode.code = "setlocal";
				continue;
			}
				// we must be in the global procedure, so the variable being created is global
			globalIndex = this.addVariable(this.variables, this.statements[i].xref);
			this.statements[i].argument = globalIndex;
			this.statements[i].xrefResolved = true;
			this.statements[i].partnerCode.code = "setglobal";
		}
	};
	
ProcedureDefinition.prototype.compile = 
	function ()
	{
		var codes = [new VmCode(1, "begin", null, null, "Start of " + this.name)];
		if (this.statements !== undefined && this.statements != null)
		{
				// If it's not the global procedure, and there are local variables,
				// then we need to create a frame for them to exist.
			var hasLocals = this.name != null && this.variables.length > 0;
			if (hasLocals)
			{
				codes.push(new VmCode(2, "byte", this.variables.length, enumArgType.BYTE, "Number of local variables"));
				codes.push(new VmCode(1, "enter"));
			}
				// Search statements for "output" to set this.returnsValue.
				// At the same time search for "return" and prepend it with 
				// "leave" if there are local variables.
			for (var i = 0; i < this.statements.length; i++)
			{
				if (this.statements[i].code == "output")
				{
					this.returnsValue = true;
					continue;
				}
					// If it's "return" and there are locals, then add a "leave"
					// before the return to clean up the locals.
				if (this.statements[i].code == "return" && hasLocals)
					this.statements.splice(i, 0, new VmCode(1, "leave"));
			}
				// Add a "leave" for the final return below if necessary
			if (hasLocals)
				this.statements.push(new VmCode(1, "leave"));
			codes = codes.concat(this.statements);
		}
		codes.push(new VmCode(1, "return", null, null, "End of " + this.name));
		this.statements = codes;
	};

function BabuinoBackEnd()
{
	this.baseAddress = 0; // For now. Be smarter later.
	this.reset();
}

BabuinoBackEnd.prototype.reset =
	function ()
	{
		this.currentPass          = 0;
		this.currentAddress       = this.baseAddress;
		//this.globalVariables      = new Array();
		this.globalTags           = new Array();
		this.currentBlock         = null;
		this.currentProc          = null;
		//this.assembly             = new Array();
		this.paramList            = null;
		//this.argListStack         = new Array();
		this.argList              = null;
		this.statementsNotArguments = null;
		this.procedureDefinitions = new Array();
		this.output      = null;
		this.errorOutput = null;
		
		this.globalProcDef        = new ProcedureDefinition(null, null, new Array());
			// Because Logo doesn't use parentheses around function parameters
			// and also has no statement terminator (such as ; in C), when the
			// parser sees a single line of function calls and parameters, it
			// can't disambiguate a parameter from a new function statement.
			// Part of the answer is to have an initial pass that only looks
			// at function signatures. The other part of the answer is to use
			// that information to pick apart and reassemble the calls as the
			// parser responds to the tokens from right to left.
			// The following is an array of arrays used to manage the
			// rearrangement.
		this.procedureCalls       = new Array();
	};
	
BabuinoBackEnd.prototype.compileInteger =
	function (value, comment)
	{
		if (this.currentPass != 2)
			return null;
		return [new VmCode(3, "short", value, enumArgType.SHORT, comment)];
	};
	
BabuinoBackEnd.prototype.compileByte =
	function (value, comment)
	{
		if (this.currentPass != 2)
			return null;
		return [new VmCode(2, "byte", value, enumArgType.BYTE, comment)];
	};	

BabuinoBackEnd.prototype.compileUnaryMinus =
	function ()
	{
		if (this.currentPass != 2)
			return null;
		var temp1 = new VmCode(2, "byte", 0, enumArgType.BYTE);
		var temp2 = new VmCode(1, "sub", null, null, "Subtract previous value from zero to get unary minus");
		return [temp1, temp2];
	};

//------------------------------------------------------------------------------
// Variables can have one of three scopes:
//   * Global    - Available to the entire program
//   * Local     - Local to a procedure
//   * Temporary - Available only within a block (eg if, else, loop, while etc.)
//
// We need to know the scope because the method of storing 
// the variables in the embedded virtual machine is different for each:
//   * Globals are stored in a table available to the whole program.
//   * Locals are pushed onto a procedure's call stack similar to a cdecl frame.
//   * Temporary variables will be stored in a reusable array. 
//
// Because the access method is different for each, a different virtual machine
// code is required. In the original Babuino code there were only global 
// variables, so there were only the SETGLOBAL and GETGLOBAL codes. Now there 
// are: setglobal/getglobal, setlocal/getlocal and settemp/gettemp.
//
// The problem is that we can't determine which code to use at the time the
// pattern is matched by the grammar engine because the context - and therefore
// the scope - is not known until later.
 
// To deal with this, a generic <setvar>/<getvar> code will be output, and the 
// variable index marked as an unresolved cross reference. The correct scope 
// and the cross reference will be resolved in a pass through the byte codes
// later in the process. Well, that's the plan anyway!
//------------------------------------------------------------------------------ 
BabuinoBackEnd.prototype.compileGetVariable =
	function (name)
	{
		if (this.currentPass != 2)
			return null;
		var temp1 = new VmCode(2, "byte", -1, enumArgType.VAR, "Index of " + name);
		temp1.xref = name;
		temp1.xrefResolved = false;
			//"<getvar>" will be changed to either "getglobal","getlocal" or 
			//"gettemp" when the scope is resolved later,
		var temp2 = new VmCode(1, "<getvar>");
		temp1.partnerCode = temp2;
		return [temp1, temp2];
	};
	
BabuinoBackEnd.prototype.compileSetVariable =
	function (name, exp)
	{
		if (this.currentPass != 2)
			return null;
		var varIndex = new VmCode(2, "byte", -1, enumArgType.VAR, "Index of " + name);
		varIndex.xref = name;
		varIndex.xrefResolved = false;
			//"<setvar>" will be changed to either "setglobal","setlocal" or 
			//"settemp" when the scope is resolved later,
		var setVar = new VmCode(1, "<setvar>");
		varIndex.partnerCode = setVar;
		//return exp.concat([temp1, temp2]);
			// The following needs to be returned for compatibility with the
			// original Babuino. 
		return [varIndex].concat(exp, [setVar]);
	};

BabuinoBackEnd.prototype.addToBlock =	
	function (statements)
	{
		if (this.currentPass != 2)
			return;
		if (this.currentBlock == null)
			this.currentBlock = new Array();
		this.currentBlock = this.currentBlock.concat(statements);
	};

BabuinoBackEnd.prototype.clearBlock =	
	function ()
	{
		this.currentBlock = null;
	};

BabuinoBackEnd.prototype.addToProc =
	function (statements)
	{
		//if (this.currentPass != 2)
		//	return;
		if (this.currentProc == null)
			this.currentProc = new Array();
		this.currentProc = this.currentProc.concat(statements);
	}

BabuinoBackEnd.prototype.clearProc =
	function ()
	{
		this.currentProc = null;
	};

BabuinoBackEnd.prototype.compileBlock = 
	function (block)
	{
		if (this.currentPass != 2)
			return null;
		var blockLength = 0;
		if (block !== undefined && block != null)
		{
			for (var i = 0; i < block.length; i++)
			{
				blockLength += block[i].length;
			}
		}
		blockLength += 1; // For added eob code 
		var blockCode = new VmCode(2, "block", blockLength, enumArgType.BYTE, "Length of this block");
		var eob  = new VmCode(1, "eob");
		
		if (block !== undefined && block != null)
		{
			var result = [blockCode].concat(block, [eob]);
			return result;
		}
		else
		{
			return [blockCode, eob];
		}
			
	};
	
BabuinoBackEnd.prototype.compileCurrentBlock = 
	function ()
	{
		if (this.currentPass != 2)
			return null;
		var result = this.compileBlock(this.currentBlock);
		this.clearBlock();
		
		return result;		
	};

BabuinoBackEnd.prototype.compileIf =
	function (exp, block)
	{
		if (this.currentPass != 2)
			return null;
		var ifCode = new VmCode(1, "if");
		return exp.concat(block).concat([ifCode]);
	};

BabuinoBackEnd.prototype.compileRepeat =
	function (exp, block)
	{
		if (this.currentPass != 2)
			return null;
		var repeatCode = new VmCode(1, "repeat");
		return exp.concat(block, [repeatCode]);
	};

BabuinoBackEnd.prototype.compileLoop =
	function (block)
	{
		if (this.currentPass != 2)
			return null;
		var loopCode = new VmCode(1, "loop");
		return block.concat([loopCode]);
	};
	
BabuinoBackEnd.prototype.compileWhile =
	function (exp, block)
	{
		if (this.currentPass != 2)
			return null;
		var whileCode = new VmCode(1, "while");
		return block.concat(exp, [whileCode]);
	};

BabuinoBackEnd.prototype.compileDoWhile =
	function (exp, block)
	{
		if (this.currentPass != 2)
			return null;
		var doCode    = new VmCode(1, "do");
		var whileCode = new VmCode(1, "while");
			
		exp[0].comment += " (\"while\" condition test)";
		return [doCode].concat(block, exp, [whileCode]);
	};
	
BabuinoBackEnd.prototype.compileWaitUntil =
	function (exp)
	{
		if (this.currentPass != 2)
			return null;
		var block = this.compileBlock(exp);
		
		return block.concat([new VmCode(1, "waituntil")]);
	};
	
BabuinoBackEnd.prototype.compileFor = 
	function(counter, from, to, step, block)
	{
		if (this.currentPass != 2)
			return null;
		from[from.length-1].comment = "from"; // This could be an expression
		to[to.length-1].comment = "to";
		step[step.length-1].comment = "step";
		    // This is i, but with no partner that will act on it
		var i = new VmCode(2, "byte", -1, enumArgType.COUNTER, "Index of " + counter);
		i.xref = counter;
		i.xrefResolved = false;
		var forCode = new VmCode(1, "for");
		return [i].concat(from, to, step, block, [forCode]);
	};	

BabuinoBackEnd.prototype.compileIfElse =
	function (exp, thenBlock, elseBlock)
	{
		if (this.currentPass != 2)
			return null;
		var ifCode = new VmCode(1, "ifelse");
		return [ifCode].concat(exp, thenBlock, elseBlock, [ifCode]);
	};

BabuinoBackEnd.prototype.compileTag =	
	function (label)
	{
		if (this.currentPass != 2)
			return null;
		var tagCode = new VmCode(0, null, label, enumArgType.TAG_DECL);
		return [tagCode];
	};
	
BabuinoBackEnd.prototype.compileGoto =	
	function (label)
	{
		if (this.currentPass != 2)
			return null;
		var addrCode = new VmCode(3, "short", null, enumArgType.TAG_REF);
		addrCode.xref = label;
		var gotoCode = new VmCode(1, "goto");
		
		return [addrCode, gotoCode];
	};
	
BabuinoBackEnd.prototype.compileWait =
	function (exp)
	{
		if (this.currentPass != 2)
			return null;
		var waitCode = new VmCode(1, "wait");
		return exp.concat([waitCode]);
	};

//------------------------------------------------------------------------------
// Cricket-compatible motor selection
//------------------------------------------------------------------------------
BabuinoBackEnd.prototype.compileSelectMotors0 =
	function (motors)
	{
		if (this.currentPass != 2)
			return null;
		var motorTokens = 
		[
			["a",     1],
			["b",     2],
			["ab",    3],
			["c",     4],
			["ac",    5],
			["bc",    6],
			["abc",   7],
			["d",     8],
			["ad",    9],
			["bd",   10],
			["abd",  11],
			["cd",   12],
			["acd",  13],
			["bcd",  14],
			["abcd", 15]
		];
		for (var i = 0; i < motorTokens.length; i++)
		{
			if (motors == motorTokens[i][0])
			{
				var select = new VmCode(2, "byte", motorTokens[i][1], enumArgType.BYTE, "Motors " + motors);
				var motors = new VmCode(1, "motors");
				return [select, motors];
			}
		}
		this.errorOutput("Motor selection " + motors + " not supported.");
		return [];
	};

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------	
BabuinoBackEnd.prototype.compileSelectMotors1 =
	function (motors)
	{
		if (this.currentPass != 2)
			return null;
		// This way of assigning motors to bits is not compatible with the
		// original Babuino, which assigned a token to each possible 
		// combination.
			//Elements correspond to motors a, b, c, d, e, f, g, h
		var flags = new Array(0, 0, 0, 0, 0, 0, 0, 0);
		var a = "a".charCodeAt(0);	// Get code for 'a'
			
		for (var i = 0; i < motors.length; i++)
		{
			var c = motors.charCodeAt(i);
			var m = c - a;		// Convert to index ('a' == 0)
			flags[m] = 1;			// Flag this motor
		}
			// Now create a binary number as bitwise flags for motors.
			// 'a' is first in the array but will be the LSB, so step
			// backwards through the array to build the argument.
		var	arg = "0b";
		for (var i = 7; i >= 0; i--)
		{
			if (flags[i] == 0)
				arg += '0';
			else
				arg += '1';
		}
		var select = new VmCode(2, "byte", arg, enumArgType.BYTE, "Motors " + motors);
		var motors = new VmCode(1, "motors");
		return [select, motors];
	};

BabuinoBackEnd.prototype.compileMotorCommand =
	function (motors, cmd)
	{
		if (this.currentPass != 2)
			return null;
			// Stick with Cricket compatibility for now
		var select = this.compileSelectMotors0(motors);
		return select.concat(cmd);
	};
	
BabuinoBackEnd.prototype.compileRandomXY =
	function (min, max)
	{
		if (this.currentPass != 2)
			return null;
		var minCode = new VmCode(3, "short", min, enumArgType.SHORT, "random lower bound");
		var maxCode = new VmCode(3, "short", max, enumArgType.SHORT, "random upper bound");
		var randCode = new VmCode(1, "randomxy");
		
		return [minCode, maxCode, randCode];
	};

BabuinoBackEnd.prototype.compileSensor =
	function (sensorNum)
	{
		if (this.currentPass != 2)
			return null;
			// For compatability, use existing sensor1 to sensor8 commands if the
			// sensor number is in that range. 
		if (sensorNum >= 1 && sensorNum <= 8)
			return [new VmCode(1, "sensor" + sensorNum)];
			
			// Otherwise have the sensor number as a byte value followed by a
			//  generic "sensor" command. This latter method means we can have
			//  as many sensors as we want.
		var numCode = new VmCode(2, "byte", sensorNum, enumArgType.BYTE, "Sensor number");
		return [numCode, new VmCode(1, "sensor")];
	};

BabuinoBackEnd.prototype.compileSwitch =
	function (switchNum)
	{
		if (this.currentPass != 2)
			return null;
			// For compatibility, use existing switch1 to switch8 commands if the
			// switch number is in that range. 
		if (switchNum >= 1 && switchNum <= 8)
			return [new VmCode(1, "switch" + switchNum)];
			
			// Otherwise have the switch number as a byte value followed by a
			// generic "switch" command. This latter method means we can have
			// as many switches as we want.
		var numCode = new VmCode(2, "byte", switchNum, enumArgType.BYTE, "Switch number");
		return [numCode, new VmCode(1, "switch")];
	};
	
BabuinoBackEnd.prototype.compileOutput =
	function (arg)
	{
		var op = [new VmCode(1, "output")];
		if (this.currentPass == 1)
		{
			return op;
		}
		else if (this.currentPass == 2)
		{
			return arg.concat(op);
		}
	};
	
BabuinoBackEnd.prototype.compileSimpleCommand =
	function (cmd)
	{
		if (this.currentPass != 2)
			return null;
		return [new VmCode(1, cmd)];
	};

BabuinoBackEnd.prototype.compileArgCommand =
	function (cmd, arg)
	{
		if (this.currentPass != 2)
			return null;
		return arg.concat([new VmCode(1, cmd)]);
	};

BabuinoBackEnd.prototype.compileExpression =
	function (lhs, op, rhs)	
	{
		if (this.currentPass != 2)
			return null;
		return lhs.concat(rhs, [new VmCode(1, op)])
	};

BabuinoBackEnd.prototype.asAssembly =
	function (byteCodes)
	{
		var str = "";
		
		if (byteCodes.length == 0)
			str = "Empty code list!";
			
		for (var i = 0; i < byteCodes.length; i++)
		{
			if (byteCodes[i].length > 0)
			{
				str += byteCodes[i].asAssembly();
				str += "\n";
			}
		}
		return str;
	};

BabuinoBackEnd.prototype.printCodes = 
	function (byteCodes)
	{
		this.output(this.asAssembly(byteCodes));
	};

BabuinoBackEnd.prototype.compileProcedureCall =
	function (name, returnValueRequired, parserSeesArgList)
	{
		if (this.currentPass != 2)
			return null;
		
		var procDef = this.findProcedureDefinition(name);
		
			// Debugging
		/*
		this.output("compileProcedureCall(" + name + ")\n{\n");
		var numParams = procDef.parameters == null ? 0 : procDef.parameters.length;
		var numArgs = this.argList == null ? 0 : this.argList.length;
		this.output("#Parameters: " + numParams + "\n");
		this.output("#Arguments: " + numArgs + "\n");
		this.output("#Output: " + (procDef.returnsValue ? "true" : "false") + "\n");
		if (this.argList != null)
			for (i = 0; i < this.argList.length; i++)
			{
				this.output("------------------------\n");
				this.printCodes(this.argList[i]);
				this.output("------------------------\n");
			}
		*/
		var args = null;
		var appendStatementsThatWereArguments = false;
		if (procDef.parameters != null && this.argList != null && parserSeesArgList)
		{
			args = null;
				// Find the last "empty argument". This will correspond to the
				// procedure call being handled here. Also see if it's the first (left-most).
				// If there are no more empty arguments (marking the place of a procedure call)
				// then this current call is the leftmost in a statement and all of the arguments,
				// including other procedure calls, should now be in place. Any arguments that
				// were found to be in fact statements can be appended after this call.
			var argIndex = -1;
			var first = true;
			for (var i = this.argList.length - 1; i >= 0; i--)
			{
				if (this.argList[i][0].code == "empty argument")
				{
					if (argIndex == -1) 
					{
						argIndex = i; // found the last (right-most)
					}
					else
					{
							// There is another call to the left. (Keep accumulating any 
							// statements mistaken for arguments.)
						first = false;
						break;
					}
				}
			}
			appendStatementsThatWereArguments = first;
				// If there's no empty argument associated with this procedure 
				// then I've screwed something up.
			if (argIndex < 0)
			{
				this.errorOutput("Internal error; Procedure " + name + " has no argument list (even an empty one).\n");
				return null;
			}
				//Now pick off the parameters
			if (procDef.parameters.length > 0)
			{
					// The number of arguments to the right of the procedure name 
					// must at least be the number of expected parameters (I'll
					// sort out variable argument lists some other time)
				var availableArgs = this.argList.length - (argIndex+1);
				if (availableArgs < procDef.parameters.length)
				{
					this.errorOutput(name + " requires " + procDef.parameters.length +
										"arguments, but has been given at most " + availableArgs + "\n");
					return null;
				}
				args = this.argList.splice(argIndex + 1, procDef.parameters.length);
			}
		}
		
		//this.output("}\n");
		var callDetails = new ProcedureCall(name, args, procDef.returnsValue, returnValueRequired, parserSeesArgList);
		var call = new VmCode(1, "call placeholder(" + name + ")" );
		call.argument = callDetails;

		var returnValue = [call];
		
		if (appendStatementsThatWereArguments)
			returnValue = returnValue.concat(this.compileStatementsMistakenForArguments());
		
		return returnValue;
	};
	
BabuinoBackEnd.prototype.compileStatementsMistakenForArguments = 
	function ()
	{
		var returnValue = new Array();
		
		if (this.statementsNotArguments != null)
		{
			for (var i = 0; i < this.statementsNotArguments.length; i++)
			{
				returnValue = returnValue.concat(this.statementsNotArguments[i]);
			}
			this.statementsNotArguments = null;
		}
		
		return returnValue;
	};

BabuinoBackEnd.prototype.resolveProcedureCrossReferences =	
	function ()
	{
		this.globalProcDef.resolveProcedureCrossReferences(this.procedureDefinitions);
		for (var i = 0; i < this.procedureDefinitions.length; i++)
		{
			this.procedureDefinitions[i].resolveProcedureCrossReferences(this.procedureDefinitions);
		}
	};

BabuinoBackEnd.prototype.addProcedureDefinition =
	function (name)
	{
		if (this.currentPass == 1)
		{
			var procDef = new ProcedureDefinition(name, this.paramList, null);
				// Look for an output code to determine if this procedure returns a value
			if (this.currentProc != null)
			{
				for (i = 0; i < this.currentProc.length; i++)
				{
					if (this.currentProc[i] != null && this.currentProc[i].code == "output")
						procDef.returnsValue = true;
				}
				this.clearProc();
			}
			this.procedureDefinitions.push(procDef);
			this.clearParameters();
		}
		else if (this.currentPass == 2)
		{
			var procDef = this.findProcedureDefinition(name);
			if (procDef != null)
			{
				procDef.statements = this.currentProc;
				this.clearProc();
			}
			else
			{
				this.output("addProcedureDefinition(): " + name + " not found!");
			}
		}
		
		 
		
	};
	
BabuinoBackEnd.prototype.findProcedureDefinition = 
	function (name)
	{
		for (var i = 0; i < this.procedureDefinitions.length; i++)
		{
			if (this.procedureDefinitions[i].name == name)
				return this.procedureDefinitions[i];
		}
		return null;
	};

BabuinoBackEnd.prototype.printProcedureDefinitions	=
	function ()
	{
		this.errorOutput("---- Procedure Definitions ----\n");
		for (var i = 0; i < this.procedureDefinitions.length; i++)
		{
			var str = this.procedureDefinitions[i].toString();
			this.errorOutput(str);
		}
		
	};
	
BabuinoBackEnd.prototype.completeProcedureCall = 
	function (codes, i)
	{
		var callPlaceholder = codes[i];
		var procedureCall = callPlaceholder.argument;
		if (procedureCall === undefined || procedureCall == null)
		{
			this.errorOutput("Procedure call to '" + procedureCall.name + "' has information missing.");
			return;
		}
		var procDef = this.findProcedureDefinition(procedureCall.name);
		if (procDef == null)
		{
			this.errorOutput("No procedure defined for '" + procedureCall.name + "'.");
			return;
		}
		if (procedureCall.returnValueRequired && !procDef.returnsValue)
		{
				// This procedure call looks like an argument to another function
				// but it can't be because it doesn't return a value. It must
				// therefore be a new statement on the same line.
			return; // To do: proper error handling.
		}
			// Determine whether to pop return value
		var cleanupReturnValue = procDef.returnsValue && !procedureCall.returnValueRequired;
		var callAddress = new VmCode(3, "short", 0, enumArgType.PROC_ADDR, "Address of " + procDef.name);
			// Mark this short as a cross reference to the procedure name and flag
			// it as unresolved.
		callAddress.xref = procDef.name;
		callAddress.xrefResolved = false;
		codes.splice(i, 1);	// Remove the placeholder
		var sequence = new Array();
		if (procDef.returnsValue)
			sequence.push(new VmCode(3, "short", 0, enumArgType.NUMBER, "space for " + procedureCall.name + " return value"));
			//Using a cdecl-like calling convention where arguments get 
			//pushed onto the stack from right to left. This means that
			//the top of the stack will have param1, and top-1 will have
			//param2 etc. This facilitates variable argument lists 
			//(although this isn't implemented yet)
		var numArgs = new VmCode(2, "byte", 0, enumArgType.BYTE, "Number of arguments");
		var call    = new VmCode(1, "call" );
		var clear   = new VmCode(2, "byte", 0, enumArgType.BYTE, "Number of arguments to remove(and return value if not used)");
		var pop     = new VmCode(1, "pop", null, null, "Clean up the stack.");
		if (procedureCall.argList != null)
		{
			for (var j = procedureCall.argList.length - 1; j >=0; j--)
			//for (var j = 0; j < procedureCall.argList.length; j++)
			{
				var args = new Array();
				//procedureCall.argList[j][procedureCall.argList[j].length - 1].comment = "Value of " + procDef.parameters[j];
				args = args.concat(procedureCall.argList[j]);
				this.completeProcedureCalls(args);	// NOTE: This call is ultimately recursive
				sequence = sequence.concat(args);
			}
			numArgs.argument = procedureCall.argList.length;	
			clear.argument += procedureCall.argList.length;
		}
			// If there are no arguments but there is a return value, then we can
			// conserve byte codes by leaving out the numArgs codes and relying on
			// the zero in the return value place holder to double-up as a zero 
			// arguments indicator. That means that we also don't need to do any
			// stack cleanup of the argument count.
		if (!(numArgs.argument == 0 && procDef.returnsValue))
		{
			sequence.push(numArgs);
			clear.argument++;		// Include the numArgs
		}
		sequence.push(callAddress);
		sequence.push(call);
		if (cleanupReturnValue)
			clear.argument++;
		if (clear.argument > 0)
		{
		  sequence.push(clear);
		  sequence.push(pop);
	  }
			
		for (var k = 0; k < sequence.length; k++)
			codes.splice(i+k, 0, sequence[k]);
	};

BabuinoBackEnd.prototype.completeProcedureCalls = 
	function (codes)
	{
		if (codes == null)
			return;
		for (var i = 0; i < codes.length; i++)
		{
			if (codes[i].code.substr(0, 16) != "call placeholder")
				continue;
			this.completeProcedureCall(codes, i);
		}
	};
	
BabuinoBackEnd.prototype.completeAllProcedureCalls = 
	function ()
	{
		this.completeProcedureCalls(this.globalProcDef.statements);
		for (var i = 0; i < this.procedureDefinitions.length; i++)
			this.completeProcedureCalls(this.procedureDefinitions[i].statements);
		
	};

BabuinoBackEnd.prototype.compileProcedureDefinitions =
	function ()
	{
		for (var i = 0; i < this.procedureDefinitions.length; i++)
		{
			this.procedureDefinitions[i].compile();
		}
	};

BabuinoBackEnd.prototype.resolveVariablesInProcedures =
	function ()
	{
			// If there's code outside of a function definition, then it's the
			// mainline. Any variables created in that code will be global.
		var haveGlobalCode = this.globalProcDef.statements.length > 0;
		if (haveGlobalCode)	
		{
				// Treat all functions, including start, as the same
				// and give them the global variables to help resolve their
				// references.
			for (var i = 0; i < this.procedureDefinitions.length; i++)
			{
				this.procedureDefinitions[i].resolveVariables(this.globalProcDef.variables);
			}
		}
		else
		{
				// No global code outside of a function definition.
				// Look for a "start" function - that will be the global code
				// and its variables will be global.
			var startIndex = -1;
			for (var i = 0; i < this.procedureDefinitions.length; i++)
			{
				if (this.procedureDefinitions[i].name == "start")
					startIndex = i;
			}
				// Now go through all the other functions and resolve their
				// variables with the variables in start given as the globals.
				// (If no start then no globals)
			var globals = startIndex == -1 ? null : this.procedureDefinitions[startIndex].variables;
			for (var i = 0; i < this.procedureDefinitions.length; i++)
			{
				if (i != startIndex)
					this.procedureDefinitions[i].resolveVariables(globals);
			}
		}
	};

BabuinoBackEnd.prototype.addParameter =
	function (param)
	{
		if (this.currentPass != 1)
			return;
		if (this.paramList == null)
			this.paramList = new Array();
			
		this.paramList.push(param);
	};

BabuinoBackEnd.prototype.clearParameters = 
	function ()
	{
		this.paramList = null;
	};



BabuinoBackEnd.prototype.addArgument =
	function (arg)
	{
		if (this.currentPass != 2)
			return;
		if (arg === undefined)
		{
			this.output("addArgument(undefined)");
			//this.clearArguments();
			return;
		}
		/*
		this.output("addArgument\n(\n");
		this.printCodes(arg);
		this.output(")\n");
		*/
		if (this.argList == null)
			this.argList = new Array();
			
		if (arg[0].code.substr(0, 16) == "call placeholder")
		{
			// All procedure arguments get reported after all value arguments.
			// Also, the procedure arguments are reported from right to left,
			// while the value arguments are reported left to right. 
			// But, if there are procedure arguments, a quirk of the parser is
			// that an empty argument is reported in the place of each procedure
			// argument in sequence with any value arguments.
			// ERRATA: ProcCallNoArg now means that an empty argument might not be
			// added.
			// So, match procedures with their empty argument proxies by searching
			// backwards from the end of the arguments.
			var argIndex = -1;
			var callDetails = arg[0].argument;
			if (callDetails.parserSeesArgList)
			{
				argIndex = this.argList.length - 1;
				while (argIndex >= 0)
				{
					if (this.argList[argIndex][0].code == "empty argument")
						break;
					argIndex--;
				}
					// If there's no empty argument associated with this procedure 
					// then I've screwed something up (or misunderstood the parser).
				if (argIndex < 0)
				{
					this.errorOutput("Internal error; Procedure " + name + " has no argument list (even an empty one).\n");
					return;
				}
			}
				// If this procedure doesn't return a value, then it's not 
				// really an argument - it's a new statement. Add it to
				// a list for appending AFTER the procedure call that
				// is receiving these arguments.
			if (!callDetails.returnsValue)
			{
				callDetails.returnValueRequired = false;
				if (this.statementsNotArguments == null)
					this.statementsNotArguments = new Array();
				this.statementsNotArguments.unshift(arg);
					// Now remove everything associated with this
					// procedure from the argument list.
					// (These arguments will already have been added to the
					// procedure's call details.
				if (callDetails.parserSeesArgList)
					this.argList.splice(argIndex, this.argList.length - argIndex);
			}
			else
			{
					// It returns a value so should take its place in the
					// argument list.
					// If the parser didn't see an argument list, then it would
					// not have added an empty argument that would have given
					// us a place to put the procedure call. In that case the
					// call should just go to the end of the argument list.
				if (callDetails.parserSeesArgList)
					this.argList[argIndex] = arg;
				else
					this.argList.push(arg);
			}
		}
		else
		{
			//this.output("addArgument(" + arg[arg.length-1].asAssembly() + ")");
			this.argList.push(arg);		
			//this.argList = this.argList.concat(arg);
		}
	};
	
//------------------------------------------------------------------------------
// An empty argument appears to be produced whenever a procedure name is
// encountered in the left to right parsing of a procedure call.  I'm using this 
// to work out the sequence of arguments to a procedure, because the parser 
// reports the adding of the actual procedure names AFTER all of the value 
// arguments have been reported. I can't see way (other than what I've 
// discovered here) to work out the full sequence of arguments including other
// procedure calls.
//------------------------------------------------------------------------------	
BabuinoBackEnd.prototype.addEmptyArgument =
	function (arg)
	{
		if (this.currentPass != 2)
			return;
		if (this.argList == null)
			this.argList = new Array();
		var call = new VmCode(0, "empty argument" );
		this.argList.push([call]);
	};	

BabuinoBackEnd.prototype.clearArguments =
	function ()
	{
		this.argList = null;
	};

BabuinoBackEnd.prototype.appendVmCodes = 
	function (codes)
	{
		if (this.currentPass != 2)
			return;
		//this.assembly = this.assembly.concat(codes);
		this.globalProcDef.statements = this.globalProcDef.statements.concat(codes);
		/*
		for (var i = 0; i < codes.length; i++)
		{
			var nextCode = codes[i];
			nextCode.address = this.currentAddress;
			this.currentAddress += nextCode.length;
		}
		*/
	};
	
BabuinoBackEnd.prototype.assignAddresses = 
	function ()
	{
		this.currentAddress = this.baseAddress;
			// Start with global code
		this.currentAddress = this.globalProcDef.assignAddresses(this.currentAddress);
			// Do the procedures separately.
			// They're not being appended to the main code yet because I don't
			// want any gotos to be resolved outside of the current procedure.
		for (var i = 0; i < this.procedureDefinitions.length; i++)
			this.currentAddress = this.procedureDefinitions[i].assignAddresses(this.currentAddress);
	};
	
BabuinoBackEnd.prototype.resolveGotos =	
	function ()
	{
		this.globalProcDef.resolveGotos();
		for (var i = 0; i < this.procedureDefinitions.length; i++)
			this.procedureDefinitions[i].resolveGotos();
	};	
	
BabuinoBackEnd.prototype.joinProcedures	 = 
	function ()
	{
		for (var i = 0; i < this.procedureDefinitions.length; i++)
		{
			if (this.procedureDefinitions[i].statements != null)
				this.globalProcDef.statements = this.globalProcDef.statements.concat(this.procedureDefinitions[i].statements);
		}
	};
	
var bbe = new BabuinoBackEnd();	

function trace(str)
{
	bbe.output(str);
	return str;
}

*]

!	" |\r|\n|\t|//[^\n]*\n"

	"if"
	"ifelse"
	"repeat"
	"loop"
	"for"
	"forever"
	"while"
	"do\.while"						DoWhile
	"to"
	"end"
	"tag"
	"goto"
	"output"
	"stop"
	"make"
	"wait"
	"waituntil"
	"ledon"
	"ledoff"
	"beep"
	"on"
	"onfor"
	"off"
	"thisway"
	"thatway"
	"rd"
	"brake"
	"setpower"
	"and"
	"or"
	"xor"
	"not"
	"true"
	"false"
	"timer"
	"resett"
	"random"
	"setsvh"
	"svr"
	"svl"
	"resetdp"
	"record"
	"recall"
	"erase"
	"send"
	"serial"
	"newserial\?"					NewSerial
	";"
	"#"
	","
	"sensor"
	"sensor[1-8]"					Sensorn	
	"switch"
	"switch[1-8]"					Switchn
	"[A-Za-z_][A-Za-z0-9_]*"		Identifier
	"\"[A-Za-z_][A-Za-z0-9_]*"		Receiver						[* %match = %match.substr( 1, %match.length - 1 ); *]
	"[A-Za-z_][A-Za-z0-9_]*\""		Label							[* %match = %match.substr( 0, %match.length - 1 ); *]
	"\:[A-Za-z_][A-Za-z0-9_]*"		Reporter						[* %match = %match.substr( 1, %match.length - 1 ); *]
	"[a-h]+,"			    		Motors							[* %match = %match.substr( 0, %match.length - 1 ); *]
	"\'([^\']|\'\')*\'"				String							[* %match = %match.substr( 1, %match.length - 2 );
																	   %match = %match.replace( /''/g, "\'" );		*]
	"-?[0-9]+"						Integer
	"-?[0-9]+\.[0-9]*|[0-9]*\.[0-9]+"	Float
	"\["
	"\]"
	"\("
	"\)"
	;

/~ Operators to be used in expressions ~/
>	"="
	"<>"
	"<="
	">="
	">"
	"<"
	;
<	"\+"
	"sum"
	"\-"
	"difference"
	;
<	"/"
	"quotient"
	"\*"
	"product"
	"%"
	"modulo"
	;
<   "not"
	"and"
	"or"
	"xor"
	;


##

Program:		Program Stmt										[* if (%2 !== undefined && %2 != null) 
																	   {
																			bbe.appendVmCodes(%2);
																	   } *]
				|
				;
				
Block:			'[' Block_Stmt_List ']'									[* %% = bbe.compileCurrentBlock(); *]
				;


Block_Stmt:		Stmt 
				|
				;
				
Block_Stmt_List:		Block_Stmt_List Block_Stmt										[* bbe.addToBlock(%2); *]
				|
				;				
		
Proc_Stmt_List:	Proc_Stmt_List Proc_Stmt									[* bbe.addToProc(%2); *]
				|
				;
				
Proc_Stmt:		Stmt 
				| 
				;					
				
Param_List:		Param_List Param									[* bbe.addParameter(%2); *]
				|
				;
				
Param:			Identifier | Reporter								
				|
				;

Arg_List:		Arg_List AddSubExp									[* bbe.addArgument(%2);*]									
				| 													[* bbe.addEmptyArgument();*]
				;
				
ProcDef:		to Identifier Param_List Proc_Stmt_List end			[* bbe.addProcedureDefinition(%2); *]
				;
				
ProcCall:		Identifier Arg_List										[* %% = %1; *]
				;

ProcCallNoArg:	Identifier 												[* %% = %1; *]
				;
				
Stmt:			if Expression Block 								[* %% = bbe.compileIf(%2, %3); *]
				| ifelse Expression Block Block 					[* %% = bbe.compileIfElse(%2, %3, %4); *]
				| repeat AddSubExp Block							[* %% = bbe.compileRepeat(%2, %3); *]
				| loop Block										[* %% = bbe.compileLoop(%2); *]
				| for '[' Identifier AddSubExp AddSubExp NegExp ']' Block	[* %% = bbe.compileFor(%3, %4, %5, %6, %8); *]
				| forever Block										[* %% = bbe.compileLoop(%2); *]
				| while Expression Block 							[* %% = bbe.compileWhile(%2, %3); *]
				| DoWhile Expression Block							[* %% = bbe.compileDoWhile(%2, %3); *]
				| tag Label											[* %% = bbe.compileTag(%2); *]
				| goto Identifier									[* %% = bbe.compileGoto(%2);*]
				| waituntil '[' Expression ']'						[* %% = bbe.compileWaitUntil(%3); *]
				| ProcDef											
				| output AddSubExp									[* %% = bbe.compileOutput(%2); *]
				| stop												[* %% = bbe.compileSimpleCommand("return"); *]
				| ProcCall									    	[* %% = bbe.compileProcedureCall(%1, false, true); *]
				| ProcCallNoArg								    	[* %% = bbe.compileProcedureCall(%1, false, false); *]
				| make Receiver Expression 							[* %% = bbe.compileSetVariable(%2, %3); *]							
				| wait AddSubExp									[* %% = bbe.compileWait(%2); *]
				| Motors Motor_cmd 									[* %% = bbe.compileMotorCommand(%1, %2); *]
				| Servo_cmd
				| Data_cmd
				| ledon												[* %% = bbe.compileSimpleCommand(%1); *]
				| ledoff 											[* %% = bbe.compileSimpleCommand(%1); *]
				| beep 												[* %% = bbe.compileSimpleCommand(%1); *]
				| resett 											[* %% = bbe.compileSimpleCommand(%1); *]
				| random AddSubExp AddSubExp						[* %% = bbe.compileRandomXY(%2, %3); *]
				| ';'												[* *]
				;
				
Expression:		Expression '=' AddSubExp							[* %% = bbe.compileExpression(%1, "eq", %3); *]
				| Expression '<' AddSubExp							[* %% = bbe.compileExpression(%1, "lt", %3); *]
				| Expression '>' AddSubExp							[* %% = bbe.compileExpression(%1, "gt", %3); *]
				| Expression '<=' AddSubExp							[* %% = bbe.compileExpression(%1, "le", %3); *]
				| Expression '>=' AddSubExp							[* %% = bbe.compileExpression(%1, "ge", %3); *]
				| Expression '<>' AddSubExp							[* %% = bbe.compileExpression(%1, "ne", %3); *]
				| '(' Expression ')'								[* %% = %2; *]
				| AddSubExp
				| LogicExp
				;
Motor_cmd:		on													[* %% = bbe.compileSimpleCommand(%1); *]
				| onfor Value  										[* %% = bbe.compileArgCommand(%1, %2); *]
				| off 												[* %% = bbe.compileSimpleCommand(%1); *]
				| thisway											[* %% = bbe.compileSimpleCommand(%1); *]
				| thatway											[* %% = bbe.compileSimpleCommand(%1); *]
				| rd												[* %% = bbe.compileSimpleCommand(%1); *]
				| brake												[* %% = bbe.compileSimpleCommand(%1); *]
				| setpower Value									[* %% = bbe.compileArgCommand(%1, %2); *] 
				;
				
Servo_cmd:		setsvh Value  										[* %% = bbe.compileArgCommand(%1, %2); *]
				| svr Value  										[* %% = bbe.compileArgCommand(%1, %2); *]
				| svl Value  										[* %% = bbe.compileArgCommand(%1, %2); *]
				;

Data_cmd:		resetdp												[* %% = bbe.compileSimpleCommand(%1); *]
				| record Value										[* %% = bbe.compileArgCommand(%1, %2); *]
				| recall Value										[* %% = bbe.compileArgCommand(%1, %2); *]
				| erase Value										[* %% = bbe.compileArgCommand(%1, %2); *]
				| send AddSubExp									[* %% = bbe.compileArgCommand(%1, %2); *]
				| send AddSubExp AddSubExp							[* %% = bbe.compileExpression(%2, "sendn", %3); *]
				;
				
AddSubExp:		AddSubExp '-' MulDivExp								[* %% = bbe.compileExpression(%1, "sub", %3); *]
				| difference AddSubExp MulDivExp					[* %% = bbe.compileExpression(%2, "sub", %3); *]
				| AddSubExp '+' MulDivExp							[* %% = bbe.compileExpression(%1, "add", %3); *]
				| sum AddSubExp MulDivExp							[* %% = bbe.compileExpression(%2, "add", %3); *]
				| '(' AddSubExp ')'									[* %% = %2; *]
				| MulDivExp
				;
				
MulDivExp:		MulDivExp '*' NegExp								[* %% = bbe.compileExpression(%1, "mul", %3); *]
				| product MulDivExp NegExp							[* %% = bbe.compileExpression(%2, "mul", %3); *]
				| MulDivExp '/' NegExp								[* %% = bbe.compileExpression(%1, "div", %3); *]
				| quotient MulDivExp NegExp							[* %% = bbe.compileExpression(%2, "div", %3); *]
				| MulDivExp '%' NegExp								[* %% = bbe.compileExpression(%1, "mod", %3); *]
				| modulo MulDivExp NegExp							[* %% = bbe.compileExpression(%2, "mod", %3); *]
				| '(' MulDivExp ')'									[* %% = %2; *]
				| NegExp
				;
				
LogicExp:		not LogicExp	    &'*'							[* %% = bbe.compileArgCommand(%1, %2); *]
				| and LogicExp LogicExp								[* %% = bbe.compileExpression(%2, %1, %3); *]
				| or LogicExp LogicExp								[* %% = bbe.compileExpression(%2, %1, %3); *]
				| xor LogicExp LogicExp								[* %% = bbe.compileExpression(%2, %1, %3); *]
				| '(' LogicExp ')'									[* %% = %2; *]
				| Value
				;
				
NegExp:			'-' Value		&'*'								[* %% = (%2).concat(bbe.compileUnaryMinus()); *]
				| Value
				;

Value:			Integer												[* %% = bbe.compileInteger(%1); *]
				| Float												[* *]
				| Reporter											[* %% = bbe.compileGetVariable(%1); *]
				| timer												[* %% = bbe.compileSimpleCommand(%1); *]
				| random											[* %% = bbe.compileSimpleCommand(%1); *]
				| true												[* %% = bbe.compileByte(-1, "=true"); *]
				| false												[* %% = bbe.compileByte(0, "=false"); *]
				| Sensorn											[* %% = bbe.compileSimpleCommand(%1); *]
				| sensor AddSubExp									[* %% = bbe.compileSensor(%1); *]
				| Switchn											[* %% = bbe.compileSimpleCommand(%1); *]
				| switch AddSubExp									[* %% = bbe.compileSwitch(%1); *]
				| serial AddSubExp									[* %% = bbe.compileArgCommand("serialn", %2); *]
				| NewSerial AddSubExp								[* %% = bbe.compileArgCommand("newserialn?", %2); *]
				| serial											[* %% = bbe.compileSimpleCommand(%1); *]
				| NewSerial											[* %% = bbe.compileSimpleCommand(%1); *]
				| ProcCall			  								[* %% = bbe.compileProcedureCall(%1, true, true);*]
				| ProcCallNoArg			  							[* %% = bbe.compileProcedureCall(%1, true, false);*]
				;
			
[*

function BabuinoLogo()
{
}
	
BabuinoLogo.prototype.parse = 
	function (text)
	{
		var error_off	= new Array();
		var error_la	= new Array();
		
		//##PREFIX##_dbg_withparsetree = true;
		//##PREFIX##_dbg_withtrace = true;
		var error_cnt = __##PREFIX##parse( text, error_off, error_la );
		if( error_cnt > 0 )
		{
			var i;
			for( var i = 0; i < error_cnt; i++ )
			{
				bbe.errorOutput( "Parse error near >" 
					+ text.substr( error_off[i], 30 ) + "<, expecting \"" + error_la[i].join() + "\"" );
			}
				
		}
		return error_cnt;
	}
	
BabuinoLogo.prototype.compile = 
	function (text, output, errorOutput)
	{
		bbe.reset();
		bbe.output      = output;
		bbe.errorOutput = errorOutput;
		
		bbe.currentPass = 1;
		var error_cnt = this.parse(text);
		if (error_cnt != 0)
			return;
		//bbe.printProcedureDefinitions();
		bbe.currentPass = 2;
		bbe.appendVmCodes([new VmCode(1, "begin", null, null, "Start of mainline")]);
		
		error_cnt = this.parse(text);
		
		if (error_cnt == 0)
		{
				// If assembly length is > 1 after the parse then there was mainline
				// code outside of any procedure. In this case add a "return".
				// Otherwise remove the "begin" and have it consist only of the 
				// procedures that will be added later (with "start" first).
			if (bbe.globalProcDef.statements.length > 1) 
			{
				bbe.appendVmCodes([new VmCode(1, "return", null, null, "End of mainline")]);
			}
			else
			{
				bbe.globalProcDef.statements.shift();
				bbe.currentAddress = 0;
			}
				// Variables need to be resolved first. This information is needed
				// in order to determine how many local variables need to be allocated
				// within each procedure. That information is needed so that the
				// the instructions can be added to allocate and clean them up.
			bbe.globalProcDef.resolveVariables(null);
			bbe.resolveVariablesInProcedures();
				// Procedures can now be compiled. In the process it is determined
				// whether the procedure returns a value. That information is needed
				// to determine whether, and how much, the calling code needs to clean
				// up after calling those procedures.
			bbe.compileProcedureDefinitions();
				
			//bbe.appendProcedures();
				// Adjustment procedure calls to clean up any unused return values.
			bbe.completeAllProcedureCalls();
				// Now that all of the instructions are in place, we can step through
				// and assign addresses.
			bbe.assignAddresses();
				// Now that everything has an address, procedure calls and gotos
				// can be resolved.
			bbe.resolveGotos();
			bbe.resolveProcedureCrossReferences();
				// procedures are currently separate from the main instruction list.
				// Join the procedure code to the main list so that what follows
				// can to be done through the whole lot.
			bbe.joinProcedures();
			
			bbe.printCodes(bbe.globalProcDef.statements);
			//bbe.printProcedureDefinitions();
		}
	};

/* Uncomment this code to use the compiler in chrome
var compileButton;
var editor;
var console;

function writeToConsole(str)
{
	console.value += str;
}

function handleCompile()
{
	var code = editor.value;
	cc.compile(code, writeToConsole, writeToConsole);
}

onConsoleLoad = function() {
  cc = new CricketCompiler();
  
  editor = document.getElementById("editor");
  console = document.getElementById("console");
  compileButton = document.getElementById("compile");

  compileButton.addEventListener("click", handleCompile);

};
*/

/* comment out the following Windows-specific code when compiling for chrome */
/*
function open_file( file )
{
	var fs = new ActiveXObject( "Scripting.FileSystemObject" );	
	var src = new String();

	if( fs && fs.fileExists( file ) )
	{
		var f = fs.OpenTextFile( file, 1 );
		if( f )
		{
			src = f.ReadAll();
			f.Close();
		}
	}
	
	return src;
}



function outputHandler(str)
{
	WScript.Echo(str);
}

function errorOutputHandler(str)
{
	WScript.Echo(str);
}

// This code will be called when the generated script is run
if( WScript.Arguments.length > 0 )
{
	var str = open_file( WScript.Arguments(0) );
	
	var bl = new BabuinoLogo();
	
	bl.compile(str, outputHandler, errorOutputHandler);
}
else
{
	errorOutputHandler( "usage: BabuinoLogo.js <filename>" );
}
*/
*]