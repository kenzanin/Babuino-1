/~
~/
	
	
[*

//--------------------------------------------------------------------------
// My stuff
var enumArgType = 
{ 
	UNKNOWN :   -1, 
	PROC_ADDR :  0, 
	VAR :        1,
    COUNTER:     2,
	TAG_DECL:    3,
	TAG_REF:     4,
	BYTE :       5, 
	SHORT :      6 
};

function VmCode(length, code, arg, argType, comment)
{
	this.address      = -1;
	this.length       = length;
	this.code         = code;
	this.argument     = arg;
	this.argumentType = argType;
	this.comment      = comment;
	this.xref         = null;
	this.xrefResolved = false;
		// This member was added so that "byte n" commands that are variable 
		// indexes can have a convenient reference to the 
		//(set|get)(global|local|temp|param) command code.
	this.partnerCode  = null;
}

VmCode.prototype.asAssembly = 
	function ()
	{
		if (this.length == 0)
			return "";
			// 4 digit padding of address
		var	str = (10000 + this.address + ": ").substr(1);
		str += this.code;
		if (this.argument !== undefined && this.argument != null)
			str += " " + this.argument;

		if (this.comment !== undefined && this.comment != null)
			str += "\t\t;" + this.comment;
		return str;
	};

function Variable(name, index)
{
	this.name  = name;
	this.index = index;
}

function TagAddress(name, address)
{
	this.name  = name;
	this.index = address;
}

function ProcedureCall(name, args, returnValueRequired)
{
	this.name = name;
	this.argList = args;
	this.returnValueRequired = returnValueRequired;
}

function ProcedureDefinition(name, parameters, statements)
{
	this.name       = name;
	this.parameters = parameters;
	this.statements = statements;
	this.address    = null;		// Calculated when the procedure is linked to the code
	this.variables  = new Array();
	this.returnsValue = false; // This will be determined later by looking for "output"
}

ProcedureDefinition.prototype.toString = 
	function ()
	{
		var str = "--------------------------------\n";
		str += "Name:            " + (this.name === undefined ? "undefined" : this.name == null ? "null" : this.name) + "\n";
		str += "Address:         " + (this.address === undefined ? "undefined" : this.address == null ? "null" : this.address) + "\n";
		str += "#Parameters:     " + (this.parameters === undefined ? "0" : this.parameters == null ? "0" : this.parameters.length) + "\n";
		str += "#Statements:     " + (this.statements === undefined ? "0" : this.statements == null ? "0" : this.statements.length) + "\n";
		str += "#Variables:      " + (this.variables === undefined ? "0" : this.variables == null ? "0" : this.variables.length) + "\n";
		str += "Returns a value: " + (this.returnsValue ? "true\n" : "false\n");
		str += "--------------------------------\n";
		
		return str;
	};

ProcedureDefinition.prototype.assignAddresses = 
	function (startAddress)
	{
		this.address    = startAddress;
		var nextAddress = startAddress;
		for (var i = 0; i < this.statements.length; i++)
		{
			this.statements[i].address = nextAddress;
			nextAddress += this.statements[i].length;
		}
		return nextAddress;
	};
	
ProcedureDefinition.prototype.resolveGotos =	
	function ()
	{
		for (var i = 0; i < this.statements.length; i++)
		{
				// Is it a goto
			if (this.statements[i].argumentType == enumArgType.TAG_REF)
			{
					// Yes. Start from the beginning and look for the tag (label)
				for (var j = 0; j < this.statements.length; j++)
				{
					if (this.statements[j].argumentType == enumArgType.TAG_DECL)
					{
						if (this.statements[j].argument == this.statements[i].xref)
						{
							this.statements[i].argument = this.statements[j].address;
							this.statements[i].xrefResolved = true;
							break;
						}
					}
				}
			}
		}
	};

ProcedureDefinition.prototype.findProcedureAddress =
	function (allProcedures, name)
	{
		//this.errorOutput("Resolving address for " + name);
		for (var i = 0; i < allProcedures.length; i++)
		{
			if (allProcedures[i].name == name)
			{
				if(allProcedures[i].address !== undefined)
				{
					//this.errorOutput("found " + name + " at " + procedureDefinitions[i].address);
					return allProcedures[i].address;
				}
			}
		}
		return -1;
	};	
	
ProcedureDefinition.prototype.resolveProcedureCrossReferences =	
	function (allDefinitions)
	{
		for (var i = 0; i < this.statements.length; i++)
		{
			if (this.statements[i].argumentType === undefined || this.statements[i].argumentType == null)
				continue;
			if (this.statements[i].argumentType !== enumArgType.PROC_ADDR)
				continue;
			if (this.statements[i].xref === undefined || this.statements[i].xref == null)
				continue;
			
			var address = this.findProcedureAddress(allDefinitions, this.statements[i].xref);
			if (address == -1)
			{
				this.errorOutput("Unable to resolve address for " + this.statements[i].xref);				
			}
			else
			{
				this.statements[i].argument = address;
				this.statements[i].xrefResolved = true;
			}
		}
	};	

ProcedureDefinition.prototype.addVariable =
	function (variables, name, id)
	{
		var newVar   = new Variable(name, variables.length);
		//newVar.name  = name;
			// if an id is provided then use it, otherwise use the index
			// into the array that holds the variable.
		if (id === undefined)
			newVar.index = variables.length;
		else
			newVar.index = id;
		variables.push(newVar);
		return newVar.index;
	};
	
ProcedureDefinition.prototype.findVariable =
	function (variables, name)
	{
		var i;
		for( var i = 0; i < variables.length; i++ )
			if( variables[i].name == name )
				return variables[i].index;
		return -1;
	};

ProcedureDefinition.prototype.resolveVariables = 
	function (globalVariables) //(codes, inProcedure, parameters)
	{
		if (this.statements === undefined || this.statements == null)
			return

			// If in global scope then use global variable table
		//var localVariables = global ? globalVariables : this.variables;
		//var localVariables = new Array();        // Variables local to a procedure
		var blockVariables = new Array();        // Stack of tables of variables
				// Counters (as used in for loops etc.) are a special case of
				// variable. Visible inside the loop, visible to the "for"
				// construct outside the loop, but not visible to code at the
				// same level as the for statement.
		//var counters = new Array();        // Stack of counter variables
				// All variables local to all blocks (eg loops) actually get stored
				// in a single array. This counter provides the index into this
				// array, while variables are actually managed here using a stack
				// of tables. (see description below)
		//var nextTempVariableIndex = 0;
		var counter = null;
		for (var i = 0; i < this.statements.length; i++)
		{
					// A "counter" argument type means that the code is a "byte" that 
					// needs to be resolved to a counter variable index. 
					// The counter is stored in the same array as temporary variables 
					// (but can only be resolved in the corresponding block and by the 
					// "for" construct).
					// These always occur just before a block.
			if (this.statements[i].argumentType == enumArgType.COUNTER)
			{
					// This will get put into the list of local variables for
					// the next block that comes along.
					
					// Create an anonymous local variable to store the temp variable
				var tempVarIndex = this.addVariable(this.variables, null);
				counter = new Variable(this.statements[i].xref, tempVarIndex);
				//counters.push(counter);
					// Borrow the msb of the variable index to use as a flag
					// indicating the first iteration of a loop. This tactic will
					// obviously fail if we have any more than 127 local variables.
				this.statements[i].argument = counter.index | 128;
				this.statements[i].xrefResolved = true;
				continue;
			}
			
				// If we're in a '[' block ']' then a variable might be in that
				// scope. Blocks/loops can be nested, with deeper blocks able to
				// access the variables of outer blocks but not vice versa. So
				// for each level, an array of variables is created and put on
				// a stack (another array). All temporary variables will
				// ultimately be assigned an index into a single array that
				// holds them all, but the stack of tables here is a temporary
				// device to limit the scope of lookups. All searches will start
				// at the top of the stack (the end of the array of tables) and
				// work backwards through the tables. As a block is exited, its
				// variable table is popped off the stack so that outer blocks
				// don't get access to it.
			if (this.statements[i].code == "block")
			{
						// A new variable table for this level
				var tempVariables = new Array();
						// If there's a counter variable then push it onto the table
						// to make it visible to the block.
				if (counter != null)
				{
						tempVariables.push(counter);
						counter = null;
				}
				blockVariables.push(tempVariables);
				continue;
			}
			if (this.statements[i].code == "eob")
			{
						// Take variables in this block out of scope
				blockVariables.pop();
				continue;
			}
			
			if (this.statements[i].argumentType === undefined || this.statements[i].argumentType == null)
				continue;
					
			if ( this.statements[i].argumentType != enumArgType.VAR)
					continue;
					
			if (this.statements[i].xref === undefined || this.statements[i].xref == null)
			{
					this.errorOutput("Cross reference expected but undefined.");
					continue;
			}
					// Need to look at the next code to see if it's a set or get.
					// Make sure there's actually a next code.
			if ((i + 1) >= this.statements.length)
			{
				this.errorOutput("Unexpected end of code.");
				return;
			}
			if (this.statements[i].partnerCode == null)
			{
				continue;
			}
			var isGet = this.statements[i].partnerCode.code == "<getvar>";
			
			var globalIndex = -1;         
			var localIndex = -1;
			var paramIndex = -1;
				// Start from the innermost level and work outwards
				// Firstly variables declared/first used in a block
			if (blockVariables.length > 0)
			{
					// We're in a block.
					// Search the stack of tables, starting with the innermost
					// table (this block's).
				for (var tableIndex = blockVariables.length -1; tableIndex >=0; tableIndex--)
				{
					var nextTable = blockVariables[tableIndex];
					localIndex = this.findVariable(nextTable, this.statements[i].xref);
					if (localIndex != -1)
						break;        // Found it
				}
			}
				// if not in a block then try variables local to the procedure
			if (localIndex == -1)
				localIndex = this.findVariable(this.variables, this.statements[i].xref);
				
			if (localIndex != -1)        // The variable is local to a procedure.
			{
					this.statements[i].argument = localIndex;
					this.statements[i].xrefResolved = true;
					this.statements[i].partnerCode.code = isGet ? "getlocal" : "setlocal";
					continue;
			}
				// Not local. Try the function parameters
			if (this.parameters !== null)
			{
					// Search parameters for the id and return the index if found
				for( var j = 0; j < this.parameters.length; j++ )
					if( this.parameters[j] == this.statements[i].xref )
						paramIndex = j;
			}
			if (paramIndex != -1)
			{
					// It's a function parameter
				if (!isGet)
				{
					this.errorOutput("Cannot assign a value to procedure parameter " + this.statements[i].xref);
				}
				this.statements[i].argument = paramIndex;
				this.statements[i].xrefResolved = true;
				this.statements[i].partnerCode.code = "getparam";        // Can't set a parameter (at this stage)
				continue;
			}
				// It's not a function parameter. Try the global variables.
				// If globalVariables == null, then this procedureDefinition is
				// the mainline and its local variables are in fact the globals
			if (globalVariables == null)
				globalIndex = this.findVariable(this.variables, this.statements[i].xref);
			else
				globalIndex = this.findVariable(globalVariables, this.statements[i].xref);
			
			if (globalIndex != -1)        // It's a global variable.
			{
					this.statements[i].argument = globalIndex;
					this.statements[i].xrefResolved = true;
					this.statements[i].partnerCode.code = isGet ? "getglobal" : "setglobal";
					continue;
			}
					// Not found anywhere. If we're just getting the variable then
					// this is an error.
			if (isGet)
			{
					this.errorOutput("The variable \"" + this.statements[i].xref + "\" is undefined.");
					continue;
			}
					// Reaching this point means that we're setting a variable that
					// doesn't exist. In LOGO that means it should be created. Decide
					// where it belongs based on the scope.
			if (blockVariables.length > 0)
			{
							// We're creating a variable within a block, so make it
							// that scope.
					var thisBlocksTable = blockVariables[blockVariables.length - 1];
						// add an anonymous local variable to store the temporary variable
					var tempVarIndex = this.addVariable(this.variables, null);
					this.statements[i].argument = this.addVariable(thisBlocksTable, this.statements[i].xref, tempVarIndex);
					this.statements[i].xrefResolved = true;
					this.statements[i].partnerCode.code = "setlocal"; //"settemp";
					continue;
			}
				// If globals aren't null then we're in a procedure
			if (globalVariables != null)
			{
				localIndex = this.addVariable(this.variables, this.statements[i].xref);
				this.statements[i].argument = localIndex;
				this.statements[i].xrefResolved = true;
				this.statements[i].partnerCode.code = "setlocal";
				continue;
			}
				// we must be in the global procedure, so the variable being created is global
			globalIndex = this.addVariable(this.variables, this.statements[i].xref);
			this.statements[i].argument = globalIndex;
			this.statements[i].xrefResolved = true;
			this.statements[i].partnerCode.code = "setglobal";
		}
	};
	
ProcedureDefinition.prototype.compile = 
	function ()
	{
		if (this.statements === undefined || this.statements == null)
			return;
		var codes = [new VmCode(1, "begin", null, null, "Start of " + this.name)];
		if (this.statements !== undefined)
		{
				// If it's not the global procedure, and there are local variables,
				// then we need to create a frame for them to exist.
			var hasLocals = this.name != null && this.variables.length > 0;
			if (hasLocals)
			{
				codes.push(new VmCode(2, "byte", this.variables.length, enumArgType.BYTE, "Number of local variables"));
				codes.push(new VmCode(1, "enter"));
			}
				// Search statements for "output" to set this.returnsValue.
				// At the same time search for "return" and prepend it with 
				// "leave" if there are local variables.
			for (var i = 0; i < this.statements.length; i++)
			{
				if (this.statements[i].code == "output")
				{
					this.returnsValue = true;
					continue;
				}
					// If it's "return" and there are locals, then add a "leave"
					// before the return to clean up the locals.
				if (this.statements[i].code == "return" && hasLocals)
					this.statements.splice(i, 0, new VmCode(1, "leave"));
			}
				// Add a "leave" for the final return below if necessary
			if (hasLocals)
				this.statements.push(new VmCode(1, "leave"));
			codes = codes.concat(this.statements);
		}
		codes.push(new VmCode(1, "return", null, null, "End of " + this.name));
		this.statements = codes;
	};

function BabuinoBackEnd()
{
	this.baseAddress = 0; // For now. Be smarter later.
	this.reset();
}

BabuinoBackEnd.prototype.reset =
	function ()
	{
		this.currentPass          = 0;
		this.currentAddress       = this.baseAddress;
		//this.globalVariables      = new Array();
		this.globalTags           = new Array();
		this.currentBlock         = null;
		this.currentProc          = null;
		//this.assembly             = new Array();
		this.paramList            = null;
		//this.argListStack         = new Array();
		this.argList              = null;
		this.procedureDefinitions = new Array();
		this.output      = null;
		this.errorOutput = null;
		
		this.globalProcDef        = new ProcedureDefinition(null, null, new Array());
	};
	
BabuinoBackEnd.prototype.compileInteger =
	function (value, comment)
	{
		if (this.currentPass != 2)
			return null;
		return [new VmCode(3, "short", value, enumArgType.SHORT, comment)];
	};
	
BabuinoBackEnd.prototype.compileByte =
	function (value, comment)
	{
		if (this.currentPass != 2)
			return null;
		return [new VmCode(2, "byte", value, enumArgType.BYTE, comment)];
	};	

BabuinoBackEnd.prototype.compileUnaryMinus =
	function ()
	{
		if (this.currentPass != 2)
			return null;
		var temp1 = new VmCode(2, "byte", 0, enumArgType.BYTE);
		var temp2 = new VmCode(1, "sub", null, null, "Subtract previous value from zero to get unary minus");
		return [temp1, temp2];
	};

//------------------------------------------------------------------------------
// Variables can have one of three scopes:
//   * Global    - Available to the entire program
//   * Local     - Local to a procedure
//   * Temporary - Available only within a block (eg if, else, loop, while etc.)
//
// We need to know the scope because the method of storing 
// the variables in the embedded virtual machine is different for each:
//   * Globals are stored in a table available to the whole program.
//   * Locals are pushed onto a procedure's call stack similar to a cdecl frame.
//   * Temporary variables will be stored in a reusable array. 
//
// Because the access method is different for each, a different virtual machine
// code is required. In the original Babuino code there were only global 
// variables, so there were only the SETGLOBAL and GETGLOBAL codes. Now there 
// are: setglobal/getglobal, setlocal/getlocal and settemp/gettemp.
//
// The problem is that we can't determine which code to use at the time the
// pattern is matched by the grammar engine because the context - and therefore
// the scope - is not known until later.
 
// To deal with this, a generic <setvar>/<getvar> code will be output, and the 
// variable index marked as an unresolved cross reference. The correct scope 
// and the cross reference will be resolved in a pass through the byte codes
// later in the process. Well, that's the plan anyway!
//------------------------------------------------------------------------------ 
BabuinoBackEnd.prototype.compileGetVariable =
	function (name)
	{
		if (this.currentPass != 2)
			return null;
		var temp1 = new VmCode(2, "byte", -1, enumArgType.VAR, "Index of " + name);
		temp1.xref = name;
		temp1.xrefResolved = false;
			//"<getvar>" will be changed to either "getglobal","getlocal" or 
			//"gettemp" when the scope is resolved later,
		var temp2 = new VmCode(1, "<getvar>");
		temp1.partnerCode = temp2;
		return [temp1, temp2];
	};
	
BabuinoBackEnd.prototype.compileSetVariable =
	function (name, exp)
	{
		if (this.currentPass != 2)
			return null;
		var varIndex = new VmCode(2, "byte", -1, enumArgType.VAR, "Index of " + name);
		varIndex.xref = name;
		varIndex.xrefResolved = false;
			//"<setvar>" will be changed to either "setglobal","setlocal" or 
			//"settemp" when the scope is resolved later,
		var setVar = new VmCode(1, "<setvar>");
		varIndex.partnerCode = setVar;
		//return exp.concat([temp1, temp2]);
			// The following needs to be returned for compatibility with the
			// original Babuino. 
		return [varIndex].concat(exp, [setVar]);
	};

BabuinoBackEnd.prototype.addToBlock =	
	function (statements)
	{
		if (this.currentPass != 2)
			return;
		if (this.currentBlock == null)
			this.currentBlock = new Array();
		this.currentBlock = this.currentBlock.concat(statements);
	};

BabuinoBackEnd.prototype.clearBlock =	
	function ()
	{
		this.currentBlock = null;
	};

BabuinoBackEnd.prototype.addToProc =
	function (statements)
	{
		if (this.currentPass != 2)
			return;
		if (this.currentProc == null)
			this.currentProc = new Array();
		this.currentProc = this.currentProc.concat(statements);
	}

BabuinoBackEnd.prototype.clearProc =
	function ()
	{
		this.currentProc = null;
	};

BabuinoBackEnd.prototype.compileBlock = 
	function (block)
	{
		if (this.currentPass != 2)
			return null;
		var blockLength = 0;
		if (block !== undefined && block != null)
		{
			for (var i = 0; i < block.length; i++)
			{
				blockLength += block[i].length;
			}
		}
		blockLength += 1; // For added eob code 
		var blockCode = new VmCode(2, "block", blockLength, enumArgType.BYTE, "Length of this block");
		var eob  = new VmCode(1, "eob");
		
		if (block !== undefined && block != null)
		{
			var result = [blockCode].concat(block, [eob]);
			return result;
		}
		else
		{
			return [blockCode, eob];
		}
			
	};
	
BabuinoBackEnd.prototype.compileCurrentBlock = 
	function ()
	{
		if (this.currentPass != 2)
			return null;
		var result = this.compileBlock(this.currentBlock);
		this.clearBlock();
		
		return result;		
	};

BabuinoBackEnd.prototype.compileIf =
	function (exp, block)
	{
		if (this.currentPass != 2)
			return null;
		var ifCode = new VmCode(1, "if");
		return exp.concat(block).concat([ifCode]);
	};

BabuinoBackEnd.prototype.compileRepeat =
	function (exp, block)
	{
		if (this.currentPass != 2)
			return null;
		var repeatCode = new VmCode(1, "repeat");
		return exp.concat(block, [repeatCode]);
	};

BabuinoBackEnd.prototype.compileLoop =
	function (block)
	{
		if (this.currentPass != 2)
			return null;
		var loopCode = new VmCode(1, "loop");
		return block.concat([loopCode]);
	};
	
BabuinoBackEnd.prototype.compileWhile =
	function (exp, block)
	{
		if (this.currentPass != 2)
			return null;
		var whileCode = new VmCode(1, "while");
		return block.concat(exp, [whileCode]);
	};

BabuinoBackEnd.prototype.compileDoWhile =
	function (exp, block)
	{
		if (this.currentPass != 2)
			return null;
		var doCode    = new VmCode(1, "do");
		var whileCode = new VmCode(1, "while");
			
		exp[0].comment += " (\"while\" condition test)";
		return [doCode].concat(block, exp, [whileCode]);
	};
	
BabuinoBackEnd.prototype.compileWaitUntil =
	function (exp)
	{
		if (this.currentPass != 2)
			return null;
		var block = this.compileBlock(exp);
		
		return block.concat([new VmCode(1, "waituntil")]);
	};
	
BabuinoBackEnd.prototype.compileFor = 
	function(counter, from, to, step, block)
	{
		if (this.currentPass != 2)
			return null;
		from[from.length-1].comment = "from"; // This could be an expression
		to[to.length-1].comment = "to";
		step[step.length-1].comment = "step";
		    // This is i, but with no partner that will act on it
		var i = new VmCode(2, "byte", -1, enumArgType.COUNTER, "Index of " + counter);
		i.xref = counter;
		i.xrefResolved = false;
		var forCode = new VmCode(1, "for");
		return [i].concat(from, to, step, block, [forCode]);
	};	

BabuinoBackEnd.prototype.compileIfElse =
	function (exp, thenBlock, elseBlock)
	{
		if (this.currentPass != 2)
			return null;
		var ifCode = new VmCode(1, "ifelse");
		return [ifCode].concat(exp, thenBlock, elseBlock, [ifCode]);
	};

BabuinoBackEnd.prototype.compileTag =	
	function (label)
	{
		if (this.currentPass != 2)
			return null;
		var tagCode = new VmCode(0, null, label, enumArgType.TAG_DECL);
		return [tagCode];
	};
	
BabuinoBackEnd.prototype.compileGoto =	
	function (label)
	{
		if (this.currentPass != 2)
			return null;
		var addrCode = new VmCode(3, "short", null, enumArgType.TAG_REF);
		addrCode.xref = label;
		var gotoCode = new VmCode(1, "goto");
		
		return [addrCode, gotoCode];
	};
	
BabuinoBackEnd.prototype.compileWait =
	function (exp)
	{
		if (this.currentPass != 2)
			return null;
		var waitCode = new VmCode(1, "wait");
		return exp.concat([waitCode]);
	};

//------------------------------------------------------------------------------
// Cricket-compatible motor selection
//------------------------------------------------------------------------------
BabuinoBackEnd.prototype.compileSelectMotors0 =
	function (motors)
	{
		if (this.currentPass != 2)
			return null;
		var motorTokens = 
		[
			["a",     1],
			["b",     2],
			["ab",    3],
			["c",     4],
			["ac",    5],
			["bc",    6],
			["abc",   7],
			["d",     8],
			["ad",    9],
			["bd",   10],
			["abd",  11],
			["cd",   12],
			["acd",  13],
			["bcd",  14],
			["abcd", 15]
		];
		for (var i = 0; i < motorTokens.length; i++)
		{
			if (motors == motorTokens[i][0])
			{
				var select = new VmCode(2, "byte", motorTokens[i][1], enumArgType.BYTE, "Motors " + motors);
				var motors = new VmCode(1, "motors");
				return [select, motors];
			}
		}
		this.errorOutput("Motor selection " + motors + " not supported.");
		return [];
	};

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------	
BabuinoBackEnd.prototype.compileSelectMotors1 =
	function (motors)
	{
		if (this.currentPass != 2)
			return null;
		// This way of assigning motors to bits is not compatible with the
		// original Babuino, which assigned a token to each possible 
		// combination.
			//Elements correspond to motors a, b, c, d, e, f, g, h
		var flags = new Array(0, 0, 0, 0, 0, 0, 0, 0);
		var a = "a".charCodeAt(0);	// Get code for 'a'
			
		for (var i = 0; i < motors.length; i++)
		{
			var c = motors.charCodeAt(i);
			var m = c - a;		// Convert to index ('a' == 0)
			flags[m] = 1;			// Flag this motor
		}
			// Now create a binary number as bitwise flags for motors.
			// 'a' is first in the array but will be the LSB, so step
			// backwards through the array to build the argument.
		var	arg = "0b";
		for (var i = 7; i >= 0; i--)
		{
			if (flags[i] == 0)
				arg += '0';
			else
				arg += '1';
		}
		var select = new VmCode(2, "byte", arg, enumArgType.BYTE, "Motors " + motors);
		var motors = new VmCode(1, "motors");
		return [select, motors];
	};

BabuinoBackEnd.prototype.compileMotorCommand =
	function (motors, cmd)
	{
		if (this.currentPass != 2)
			return null;
			// Stick with Cricket compatibility for now
		var select = this.compileSelectMotors0(motors);
		return select.concat(cmd);
	};
	
BabuinoBackEnd.prototype.compileRandomXY =
	function (min, max)
	{
		if (this.currentPass != 2)
			return null;
		var minCode = new VmCode(3, "short", min, enumArgType.SHORT, "random lower bound");
		var maxCode = new VmCode(3, "short", max, enumArgType.SHORT, "random upper bound");
		var randCode = new VmCode(1, "randomxy");
		
		return [minCode, maxCode, randCode];
	};

BabuinoBackEnd.prototype.compileSensor =
	function (sensorNum)
	{
		if (this.currentPass != 2)
			return null;
			// For compatability, use existing sensor1 to sensor8 commands if the
			// sensor number is in that range. 
		if (sensorNum >= 1 && sensorNum <= 8)
			return [new VmCode(1, "sensor" + sensorNum)];
			
			// Otherwise have the sensor number as a byte value followed by a
			//  generic "sensor" command. This latter method means we can have
			//  as many sensors as we want.
		var numCode = new VmCode(2, "byte", sensorNum, enumArgType.BYTE, "Sensor number");
		return [numCode, new VmCode(1, "sensor")];
	};

BabuinoBackEnd.prototype.compileSwitch =
	function (switchNum)
	{
		if (this.currentPass != 2)
			return null;
			// For compatibility, use existing switch1 to switch8 commands if the
			// switch number is in that range. 
		if (switchNum >= 1 && switchNum <= 8)
			return [new VmCode(1, "switch" + switchNum)];
			
			// Otherwise have the switch number as a byte value followed by a
			// generic "switch" command. This latter method means we can have
			// as many switches as we want.
		var numCode = new VmCode(2, "byte", switchNum, enumArgType.BYTE, "Switch number");
		return [numCode, new VmCode(1, "switch")];
	};
	
BabuinoBackEnd.prototype.compileSimpleCommand =
	function (cmd)
	{
		if (this.currentPass != 2)
			return null;
		return [new VmCode(1, cmd)];
	};

BabuinoBackEnd.prototype.compileArgCommand =
	function (cmd, arg)
	{
		if (this.currentPass != 2)
			return null;
		return arg.concat([new VmCode(1, cmd)]);
	};

BabuinoBackEnd.prototype.compileExpression =
	function (lhs, op, rhs)	
	{
		if (this.currentPass != 2)
			return null;
		return lhs.concat(rhs, [new VmCode(1, op)])
	};

BabuinoBackEnd.prototype.asAssembly =
	function (byteCodes)
	{
		var str = "";
		
		if (byteCodes.length == 0)
			str = "Empty code list!";
			
		for (var i = 0; i < byteCodes.length; i++)
		{
			if (byteCodes[i].length > 0)
			{
				str += byteCodes[i].asAssembly();
				str += "\n";
			}
		}
		return str;
	};

BabuinoBackEnd.prototype.printCodes = 
	function (byteCodes)
	{
		this.output(this.asAssembly(byteCodes));
	};

BabuinoBackEnd.prototype.compileProcedureCall =
	function (name, returnValueRequired)
	{
		if (this.currentPass != 2)
			return null;
		//this.output("compileProcedureCall(" + name + ")");
		/*
			// We have almost all the information we need to make the procedure
			// call. However, because we don't necessarily have the definition
			// for the procedure being called, we don't know if it returns a 
			// value. We need to know that in order to clean up properly.
			// So, just put a placeholder where the call is, and store the
			// contextual information so that all of the necessary codes can be
			// inserted later (after all of the procedure definitions are known)
		var callDetails = new ProcedureCall(name, this.argList, returnValueRequired);
		this.clearArguments();
		var call = new VmCode(0, "call placeholder" );
		call.argument = callDetails;
		
		return [call];
		*/
			// experimental (code must have procedures defined before being called)
		var procDef = this.findProcedureDefinition(name);
		
		var args = null;
		if (procDef.parameters != null && this.argList != null)
		{
			args = new Array();
			for (i = 0; i < procDef.parameters.length; i++)
			{
					// Argument in the list are in the correct order, but we
					// need to take the current procedure's arguments from the end.
					// Remove from the end and place at the beginning of our sub-list.
				var nextArg = this.argList.pop();
				args.unshift(nextArg);
			}
		}
		var callDetails = new ProcedureCall(name, args, returnValueRequired);
		var call = new VmCode(0, "call placeholder" );
		call.argument = callDetails;
		
		return [call];
	};

BabuinoBackEnd.prototype.resolveProcedureCrossReferences =	
	function ()
	{
		this.globalProcDef.resolveProcedureCrossReferences(this.procedureDefinitions);
		for (var i = 0; i < this.procedureDefinitions.length; i++)
		{
			this.procedureDefinitions[i].resolveProcedureCrossReferences(this.procedureDefinitions);
		}
	};

BabuinoBackEnd.prototype.addProcedureDefinition =
	function (name)
	{
		if (this.currentPass == 1)
		{
			var procDef = new ProcedureDefinition(name, this.paramList, null);
			this.procedureDefinitions.push(procDef);
			this.clearParameters();
		}
		else if (this.currentPass == 2)
		{
			var procDef = this.findProcedureDefinition(name);
			if (procDef != null)
			{
				procDef.statements = this.currentProc;
				this.clearProc();
			}
			else
			{
				this.output("addProcedureDefinition(): " + name + " not found!");
			}
		}
		
		 
		
	};
	
BabuinoBackEnd.prototype.findProcedureDefinition = 
	function (name)
	{
		for (var i = 0; i < this.procedureDefinitions.length; i++)
		{
			if (this.procedureDefinitions[i].name == name)
				return this.procedureDefinitions[i];
		}
		return null;
	};

BabuinoBackEnd.prototype.printProcedureDefinitions	=
	function ()
	{
		this.errorOutput("---- Procedure Definitions ----\n");
		for (var i = 0; i < this.procedureDefinitions.length; i++)
		{
			var str = this.procedureDefinitions[i].toString();
			this.errorOutput(str);
		}
		
	};
	
BabuinoBackEnd.prototype.completeProcedureCall = 
	function (codes, i)
	{
		var callPlaceholder = codes[i];
		var procedureCall = callPlaceholder.argument;
		if (procedureCall === undefined || procedureCall == null)
		{
			this.errorOutput("Procedure call to '" + procedureCall.name + "' has information missing.");
			return;
		}
		var procDef = this.findProcedureDefinition(procedureCall.name);
		if (procDef == null)
		{
			this.errorOutput("No procedure defined for '" + procedureCall.name + "'.");
			return;
		}
		if (procedureCall.returnValueRequired && !procDef.returnsValue)
		{
			this.errorOutput("A call to " + procedureCall.name + 
							 " expects a return value, but that procedure doesn't return any value.");
			return; // To do: proper error handling.
		}
			// Determine whether to pop return value
		var cleanupReturnValue = procDef.returnsValue && !procedureCall.returnValueRequired;
		var callAddress = new VmCode(3, "short", 0, enumArgType.PROC_ADDR, "Address of " + procDef.name);
			// Mark this short as a cross reference to the procedure name and flag
			// it as unresolved.
		callAddress.xref = procDef.name;
		callAddress.xrefResolved = false;
		codes.splice(i, 1);	// Remove the placeholder
		var sequence = new Array();
		if (procDef.returnsValue)
			sequence.push(new VmCode(3, "short", 0, enumArgType.NUMBER, "space for " + procedureCall.name + " return value"));
			//Using a cdecl-like calling convention where arguments get 
			//pushed onto the stack from right to left. This means that
			//the top of the stack will have param1, and top-1 will have
			//param2 etc. This facilitates variable argument lists 
			//(although this isn't implemented yet)
		var numArgs = new VmCode(2, "byte", 0, enumArgType.BYTE, "Number of arguments");
		var call    = new VmCode(1, "call" );
		var clear   = new VmCode(2, "byte", 1, enumArgType.BYTE, "Number of arguments to remove(and return value if not used)");
		var pop     = new VmCode(1, "pop", null, null, "Clean up the stack.");
		if (procedureCall.argList != null)
		{
			//for (var j = procedureCall.argList.length - 1; j >=0; j--)
			for (var j = 0; j < procedureCall.argList.length; j++)
			{
				var args = new Array();
				//procedureCall.argList[j][procedureCall.argList[j].length - 1].comment = "Value of " + procDef.parameters[j];
				args = args.concat(procedureCall.argList[j]);
				this.completeProcedureCalls(args);	// NOTE: This call is ultimately recursive
				sequence = sequence.concat(args);
			}
			numArgs.argument = procedureCall.argList.length;	
			clear.argument += procedureCall.argList.length;
		}
		sequence.push(numArgs);
		sequence.push(callAddress);
		sequence.push(call);
		if (cleanupReturnValue)
			clear.argument++;
		sequence.push(clear);
		sequence.push(pop);
			
		for (var k = 0; k < sequence.length; k++)
			codes.splice(i+k, 0, sequence[k]);
	};

BabuinoBackEnd.prototype.completeProcedureCalls = 
	function (codes)
	{
		for (var i = 0; i < codes.length; i++)
		{
			if (codes[i].code != "call placeholder")
				continue;
			this.completeProcedureCall(codes, i);
		}
	};
	
BabuinoBackEnd.prototype.completeAllProcedureCalls = 
	function ()
	{
		this.completeProcedureCalls(this.globalProcDef.statements);
		for (var i = 0; i < this.procedureDefinitions.length; i++)
			this.completeProcedureCalls(this.procedureDefinitions[i].statements);
		
	};

BabuinoBackEnd.prototype.compileProcedureDefinitions =
	function ()
	{
		for (var i = 0; i < this.procedureDefinitions.length; i++)
		{
			this.procedureDefinitions[i].compile();
		}
	};

BabuinoBackEnd.prototype.resolveVariablesInProcedures =
	function ()
	{
			// If there's code outside of a function definition, then it's the
			// mainline. Any variables created in that code will be global.
		var haveGlobalCode = this.globalProcDef.statements.length > 0;
		if (haveGlobalCode)	
		{
				// Treat all functions, including start, as the same
				// and give them the global variables to help resolve their
				// references.
			for (var i = 0; i < this.procedureDefinitions.length; i++)
			{
				this.procedureDefinitions[i].resolveVariables(this.globalProcDef.variables);
			}
		}
		else
		{
				// No global code outside of a function definition.
				// Look for a "start" function - that will be the global code
				// and its variables will be global.
			var startIndex = -1;
			for (var i = 0; i < this.procedureDefinitions.length; i++)
			{
				if (this.procedureDefinitions[i].name == "start")
					startIndex = i;
			}
				// Now go through all the other functions and resolve their
				// variables with the variables in start given as the globals.
				// (If no start then no globals)
			var globals = startIndex == -1 ? null : this.procedureDefinitions[startIndex].variables;
			for (var i = 0; i < this.procedureDefinitions.length; i++)
			{
				if (i != startIndex)
					this.procedureDefinitions[i].resolveVariables(globals);
			}
		}
	};

BabuinoBackEnd.prototype.addParameter =
	function (param)
	{
		if (this.currentPass != 1)
			return;
		if (this.paramList == null)
			this.paramList = new Array();
			
		this.paramList.push(param);
	};

BabuinoBackEnd.prototype.clearParameters = 
	function ()
	{
		this.paramList = null;
	};



BabuinoBackEnd.prototype.addArgument =
	function (arg)
	{
		if (this.currentPass != 2)
			return;
		if (arg === undefined)
		{
			this.output("addArgument(undefined)");
			//this.clearArguments();
			return;
		}
		if (this.argList == null)
			this.argList = new Array();
		//this.output("addArgument(" + arg[arg.length-1].asAssembly() + ")");
		this.argList.push(arg);		
		//this.argList = this.argList.concat(arg);
	};

BabuinoBackEnd.prototype.clearArguments =
	function ()
	{
		this.argList = null;
	};

BabuinoBackEnd.prototype.appendVmCodes = 
	function (codes)
	{
		if (this.currentPass != 2)
			return;
		//this.assembly = this.assembly.concat(codes);
		this.globalProcDef.statements = this.globalProcDef.statements.concat(codes);
		/*
		for (var i = 0; i < codes.length; i++)
		{
			var nextCode = codes[i];
			nextCode.address = this.currentAddress;
			this.currentAddress += nextCode.length;
		}
		*/
	};
	
BabuinoBackEnd.prototype.assignAddresses = 
	function ()
	{
		this.currentAddress = this.baseAddress;
			// Start with global code
		this.currentAddress = this.globalProcDef.assignAddresses(this.currentAddress);
			// Do the procedures separately.
			// They're not being appended to the main code yet because I don't
			// want any gotos to be resolved outside of the current procedure.
		for (var i = 0; i < this.procedureDefinitions.length; i++)
			this.currentAddress = this.procedureDefinitions[i].assignAddresses(this.currentAddress);
	};
	
BabuinoBackEnd.prototype.resolveGotos =	
	function ()
	{
		this.globalProcDef.resolveGotos();
		for (var i = 0; i < this.procedureDefinitions.length; i++)
			this.procedureDefinitions[i].resolveGotos();
	};	
	
BabuinoBackEnd.prototype.joinProcedures	 = 
	function ()
	{
		for (var i = 0; i < this.procedureDefinitions.length; i++)
		{
			if (this.procedureDefinitions[i].statements != null)
				this.globalProcDef.statements = this.globalProcDef.statements.concat(this.procedureDefinitions[i].statements);
		}
	};
	
var bbe = new BabuinoBackEnd();	

function trace(str)
{
	bbe.output(str);
	return str;
}

*]

!	" |\r|\n|\t|//[^\n]*\n"

	"if"
	"ifelse"
	"repeat"
	"loop"
	"for"
	"forever"
	"while"
	"do\.while"						DoWhile
	"to"
	"end"
	"tag"
	"goto"
	"output"
	"stop"
	"make"
	"wait"
	"waituntil"
	"ledon"
	"ledoff"
	"beep"
	"on"
	"onfor"
	"off"
	"thisway"
	"thatway"
	"rd"
	"brake"
	"setpower"
	"and"
	"or"
	"xor"
	"not"
	"true"
	"false"
	"timer"
	"resett"
	"random"
	"setsvh"
	"svr"
	"svl"
	"resetdp"
	"record"
	"recall"
	"erase"
	"send"
	"serial"
	"newserial\?"					NewSerial
	"sum"
	"difference"
	"product"
	"quotient"
	"modulo"
	"\["
	"\]"
	";"
	"="
	"<>"
	"<="
	">="
	">"
	"<"
	"\+"
	"\-"
	"/"
	"\*"
	"%"
	"\("
	"\)"
	"#"
	","
	"^"						SOL
	"sensor"
	"sensor[1-8]"					Sensorn	
	"switch"
	"switch[1-8]"					Switchn
	"[A-Za-z_][A-Za-z0-9_]*"		Identifier
	"\"[A-Za-z_][A-Za-z0-9_]*"		Receiver						[* %match = %match.substr( 1, %match.length - 1 ); *]
	"[A-Za-z_][A-Za-z0-9_]*\""		Label							[* %match = %match.substr( 0, %match.length - 1 ); *]
	"\:[A-Za-z_][A-Za-z0-9_]*"		Reporter						[* %match = %match.substr( 1, %match.length - 1 ); *]
	"[a-h]+,"			    		Motors							[* %match = %match.substr( 0, %match.length - 1 ); *]
	"\'([^\']|\'\')*\'"				String							[* %match = %match.substr( 1, %match.length - 2 );
																	   %match = %match.replace( /''/g, "\'" );		*]
	"-?[0-9]+"						Integer
	"-?[0-9]+\.[0-9]*|[0-9]*\.[0-9]+"	Float
	;

/~ Operators to be used in expressions ~/
>	"="
	"<>"
	"<="
	">="
	">"
	"<"
	;
<	"\+"
	"\-"
	;
<	"/"
	"\*"
	;
<   "not"
	"and"
	"or"
	"xor"
	;

##

Program:		Program Stmt										[* if (%2 !== undefined && %2 != null) 
																	   {
																			bbe.appendVmCodes(%2);
																	   } *]
				|
				;
		
Proc_Stmt_List:	Proc_Stmt_List Stmt									[* bbe.addToProc(%2); *]
				|
				;
				
Stmt_List:		Stmt_List Stmt										[* bbe.addToBlock(%2); *]
				|
				;
				
Arg_List:		Arg_List AddSubExp									[* bbe.addArgument(%2);*]								
				|
				;
				
Param_List:		Param_List Param									[* bbe.addParameter(%2); *]
				|
				;

Param:			Identifier | Reporter								
				|
				;
				
ProcDef:		to Identifier Param_List Proc_Stmt_List end			[* bbe.addProcedureDefinition(%2); *]
				;
				
ProcCall:		Identifier Arg_List									[* %% = %1; /*bbe.compileProcedureCall(%1);*/ *]			
				;
				
Block:			'[' Stmt_List ']'									[* %% = bbe.compileCurrentBlock(); *]
				;
				
Stmt:			if Expression Block 								[* %% = bbe.compileIf(%2, %3); *]
				| ifelse Expression Block Block 					[* %% = bbe.compileIfElse(%2, %3, %4); *]
				| repeat AddSubExp Block							[* %% = bbe.compileRepeat(%2, %3); *]
				| loop Block										[* %% = bbe.compileLoop(%2); *]
				| for '[' Identifier AddSubExp AddSubExp NegExp ']' Block	[* %% = bbe.compileFor(%3, %4, %5, %6, %8); *]
				| forever Block										[* %% = bbe.compileLoop(%2); *]
				| while Expression Block 							[* %% = bbe.compileWhile(%2, %3); *]
				| DoWhile Expression Block							[* %% = bbe.compileDoWhile(%2, %3); *]
				| tag Label											[* %% = bbe.compileTag(%2); *]
				| goto Identifier									[* %% = bbe.compileGoto(%2);*]
				| waituntil '[' Expression ']'						[* %% = bbe.compileWaitUntil(%3); *]
				| ProcDef											
				| output AddSubExp									[* %% = bbe.compileArgCommand(%1, %2); *]
				| stop												[* %% = bbe.compileSimpleCommand("return"); *]
				| ProcCall							        		[* %% = bbe.compileProcedureCall(%1, false); *]
				| make Receiver Expression 							[* %% = bbe.compileSetVariable(%2, %3); *]							
				| wait AddSubExp									[* %% = bbe.compileWait(%2); *]
				| Motors Motor_cmd 									[* %% = bbe.compileMotorCommand(%1, %2); *]
				| Servo_cmd
				| Data_cmd
				| ledon												[* %% = bbe.compileSimpleCommand(%1); *]
				| ledoff 											[* %% = bbe.compileSimpleCommand(%1); *]
				| beep 												[* %% = bbe.compileSimpleCommand(%1); *]
				| resett 											[* %% = bbe.compileSimpleCommand(%1); *]
				| random AddSubExp AddSubExp						[* %% = bbe.compileRandomXY(%2, %3); *]
				| ';'												[*  *]
				;
				
Expression:		Expression '=' AddSubExp							[* %% = bbe.compileExpression(%1, "eq", %3); *]
				| Expression '<' AddSubExp							[* %% = bbe.compileExpression(%1, "lt", %3); *]
				| Expression '>' AddSubExp							[* %% = bbe.compileExpression(%1, "gt", %3); *]
				| Expression '<=' AddSubExp							[* %% = bbe.compileExpression(%1, "le", %3); *]
				| Expression '>=' AddSubExp							[* %% = bbe.compileExpression(%1, "ge", %3); *]
				| Expression '<>' AddSubExp							[* %% = bbe.compileExpression(%1, "ne", %3); *]
				| AddSubExp
				| LogicExp
				;
Motor_cmd:		on													[* %% = bbe.compileSimpleCommand(%1); *]
				| onfor Value  										[* %% = bbe.compileArgCommand(%1, %2); *]
				| off 												[* %% = bbe.compileSimpleCommand(%1); *]
				| thisway											[* %% = bbe.compileSimpleCommand(%1); *]
				| thatway											[* %% = bbe.compileSimpleCommand(%1); *]
				| rd												[* %% = bbe.compileSimpleCommand(%1); *]
				| brake												[* %% = bbe.compileSimpleCommand(%1); *]
				| setpower Value									[* %% = bbe.compileArgCommand(%1, %2); *] 
				;
				
Servo_cmd:		setsvh Value  										[* %% = bbe.compileArgCommand(%1, %2); *]
				| svr Value  										[* %% = bbe.compileArgCommand(%1, %2); *]
				| svl Value  										[* %% = bbe.compileArgCommand(%1, %2); *]
				;

Data_cmd:		resetdp												[* %% = bbe.compileSimpleCommand(%1); *]
				| record Value										[* %% = bbe.compileArgCommand(%1, %2); *]
				| recall Value										[* %% = bbe.compileArgCommand(%1, %2); *]
				| erase Value										[* %% = bbe.compileArgCommand(%1, %2); *]
				| send AddSubExp									[* %% = bbe.compileArgCommand(%1, %2); *]
				| send AddSubExp AddSubExp							[* %% = bbe.compileExpression(%2, "sendn", %3); *]
				;
				
AddSubExp:		AddSubExp '-' MulDivExp								[* %% = bbe.compileExpression(%1, "sub", %3); *]
				| difference AddSubExp MulDivExp					[* %% = bbe.compileExpression(%2, "sub", %3); *]
				| AddSubExp '+' MulDivExp							[* %% = bbe.compileExpression(%1, "add", %3); *]
				| sum AddSubExp MulDivExp							[* %% = bbe.compileExpression(%2, "add", %3); *]
				| MulDivExp
				;
				
MulDivExp:		MulDivExp '*' NegExp								[* %% = bbe.compileExpression(%1, "mul", %3); *]
				| product MulDivExp NegExp							[* %% = bbe.compileExpression(%2, "mul", %3); *]
				| MulDivExp '/' NegExp								[* %% = bbe.compileExpression(%1, "div", %3); *]
				| quotient MulDivExp NegExp							[* %% = bbe.compileExpression(%2, "div", %3); *]
				| MulDivExp '%' NegExp								[* %% = bbe.compileExpression(%1, "mod", %3); *]
				| modulo MulDivExp NegExp							[* %% = bbe.compileExpression(%2, "mod", %3); *]
				| NegExp
				;
				
LogicExp:		not LogicExp	    &'*'							[* %% = bbe.compileArgCommand(%1, %2); *]
				| and LogicExp LogicExp								[* %% = bbe.compileExpression(%2, %1, %3); *]
				| or LogicExp LogicExp								[* %% = bbe.compileExpression(%2, %1, %3); *]
				| xor LogicExp LogicExp								[* %% = bbe.compileExpression(%2, %1, %3); *]
				| Value
				;
				
NegExp:			'-' Value		&'*'								[* %% = (%2).concat(bbe.compileUnaryMinus()); *]
				| Value
				;

Value:			Integer												[* %% = bbe.compileInteger(%1); *]
				| Float												[* *]
				| Reporter											[* %% = bbe.compileGetVariable(%1); *]
				| '[' Expression ']'								[* %% = %2; *]
				| timer												[* %% = bbe.compileSimpleCommand(%1); *]
				| random											[* %% = bbe.compileSimpleCommand(%1); *]
				| true												[* %% = bbe.compileByte(-1, "=true"); *]
				| false												[* %% = bbe.compileByte(0, "=false"); *]
				| Sensorn											[* %% = bbe.compileSimpleCommand(%1); *]
				| sensor AddSubExp									[* %% = bbe.compileSensor(%1); *]
				| Switchn											[* %% = bbe.compileSimpleCommand(%1); *]
				| switch AddSubExp									[* %% = bbe.compileSwitch(%1); *]
				| serial AddSubExp									[* %% = bbe.compileArgCommand("serialn", %2); *]
				| NewSerial AddSubExp								[* %% = bbe.compileArgCommand("newserialn?", %2); *]
				| serial											[* %% = bbe.compileSimpleCommand(%1); *]
				| NewSerial											[* %% = bbe.compileSimpleCommand(%1); *]
				| ProcCall							        		[* %% = bbe.compileProcedureCall(%1, true);*]
				;
			
[*

function BabuinoLogo()
{
}
	
BabuinoLogo.prototype.parse = 
	function (text)
	{
		var error_off	= new Array();
		var error_la	= new Array();
		
		//##PREFIX##_dbg_withparsetree = true;
		//##PREFIX##_dbg_withtrace = true;
		var error_cnt = __##PREFIX##parse( text, error_off, error_la );
		if( error_cnt > 0 )
		{
			var i;
			for( var i = 0; i < error_cnt; i++ )
			{
				bbe.errorOutput( "Parse error near >" 
					+ text.substr( error_off[i], 30 ) + "<, expecting \"" + error_la[i].join() + "\"" );
			}
				
		}
		return error_cnt;
	}
	
BabuinoLogo.prototype.compile = 
	function (text, output, errorOutput)
	{
		bbe.reset();
		bbe.output      = output;
		bbe.errorOutput = errorOutput;
		
		bbe.currentPass = 1;
		var error_cnt = this.parse(text);
		if (error_cnt != 0)
			return;
		//bbe.printProcedureDefinitions();
		bbe.currentPass = 2;
		bbe.appendVmCodes([new VmCode(1, "begin", null, null, "Start of mainline")]);
		
		error_cnt = this.parse(text);
		
		if (error_cnt == 0)
		{
				// If assembly length is > 1 after the parse then there was mainline
				// code outside of any procedure. In this case add a "return".
				// Otherwise remove the "begin" and have it consist only of the 
				// procedures that will be added later (with "start" first).
			if (bbe.globalProcDef.statements.length > 1) 
			{
				bbe.appendVmCodes([new VmCode(1, "return", null, null, "End of mainline")]);
			}
			else
			{
				bbe.globalProcDef.statements.shift();
				bbe.currentAddress = 0;
			}
				// Variables need to be resolved first. This information is needed
				// in order to determine how many local variables need to be allocated
				// within each procedure. That information is needed so that the
				// the instructions can be added to allocate and clean them up.
			bbe.globalProcDef.resolveVariables(null);
			bbe.resolveVariablesInProcedures();
				// Procedures can now be compiled. In the process it is determined
				// whether the procedure returns a value. That information is needed
				// to determine whether, and how much, the calling code needs to clean
				// up after calling those procedures.
			bbe.compileProcedureDefinitions();
				
			//bbe.appendProcedures();
				// Adjustment procedure calls to clean up any unused return values.
			bbe.completeAllProcedureCalls();
				// Now that all of the instructions are in place, we can step through
				// and assign addresses.
			bbe.assignAddresses();
				// Now that everything has an address, procedure calls and gotos
				// can be resolved.
			bbe.resolveGotos();
			bbe.resolveProcedureCrossReferences();
				// procedures are currently separate from the main instruction list.
				// Join the procedure code to the main list so that what follows
				// can to be done through the whole lot.
			bbe.joinProcedures();
			
			bbe.printCodes(bbe.globalProcDef.statements);
			//bbe.printProcedureDefinitions();
		}
	};

/* Uncomment this code to use the compiler in chrome
var compileButton;
var editor;
var console;

function writeToConsole(str)
{
	console.value += str;
}

function handleCompile()
{
	var code = editor.value;
	cc.compile(code, writeToConsole, writeToConsole);
}

onConsoleLoad = function() {
  cc = new CricketCompiler();
  
  editor = document.getElementById("editor");
  console = document.getElementById("console");
  compileButton = document.getElementById("compile");

  compileButton.addEventListener("click", handleCompile);

};
*/

/* comment out the following Windows-specific code when compiling for chrome */
/*
function open_file( file )
{
	var fs = new ActiveXObject( "Scripting.FileSystemObject" );	
	var src = new String();

	if( fs && fs.fileExists( file ) )
	{
		var f = fs.OpenTextFile( file, 1 );
		if( f )
		{
			src = f.ReadAll();
			f.Close();
		}
	}
	
	return src;
}



function outputHandler(str)
{
	WScript.Echo(str);
}

function errorOutputHandler(str)
{
	WScript.Echo(str);
}

// This code will be called when the generated script is run
if( WScript.Arguments.length > 0 )
{
	var str = open_file( WScript.Arguments(0) );
	
	var bl = new BabuinoLogo();
	
	bl.compile(str, outputHandler, errorOutputHandler);
}
else
{
	errorOutputHandler( "usage: BabuinoLogo.js <filename>" );
}
*/
*]